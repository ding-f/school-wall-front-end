{"version":3,"sources":["index.js","dist/server-renderer.cjs.prod.js","dist/server-renderer.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;AELA,ADGA,ADGA;AELA,ADGA,ADGA;AELA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA,ADGA;ACFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nif (process.env.NODE_ENV === 'production') {\n  module.exports = require('./dist/server-renderer.cjs.prod.js')\n} else {\n  module.exports = require('./dist/server-renderer.cjs.js')\n}\n","\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar vue = require('vue');\nvar shared = require('@vue/shared');\nvar compilerSsr = require('@vue/compiler-ssr');\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n// leading comma for empty string \"\"\r\nconst shouldIgnoreProp = shared.makeMap(`,key,ref,innerHTML,textContent`);\r\nfunction ssrRenderAttrs(props, tag) {\r\n    let ret = '';\r\n    for (const key in props) {\r\n        if (shouldIgnoreProp(key) ||\r\n            shared.isOn(key) ||\r\n            (tag === 'textarea' && key === 'value')) {\r\n            continue;\r\n        }\r\n        const value = props[key];\r\n        if (key === 'class') {\r\n            ret += ` class=\"${ssrRenderClass(value)}\"`;\r\n        }\r\n        else if (key === 'style') {\r\n            ret += ` style=\"${ssrRenderStyle(value)}\"`;\r\n        }\r\n        else {\r\n            ret += ssrRenderDynamicAttr(key, value, tag);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n// render an attr with dynamic (unknown) key.\r\nfunction ssrRenderDynamicAttr(key, value, tag) {\r\n    if (!isRenderableValue(value)) {\r\n        return ``;\r\n    }\r\n    const attrKey = tag && tag.indexOf('-') > 0\r\n        ? key // preserve raw name on custom elements\r\n        : shared.propsToAttrMap[key] || key.toLowerCase();\r\n    if (shared.isBooleanAttr(attrKey)) {\r\n        return shared.includeBooleanAttr(value) ? ` ${attrKey}` : ``;\r\n    }\r\n    else if (shared.isSSRSafeAttrName(attrKey)) {\r\n        return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${shared.escapeHtml(value)}\"`;\r\n    }\r\n    else {\r\n        console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);\r\n        return ``;\r\n    }\r\n}\r\n// Render a v-bind attr with static key. The key is pre-processed at compile\r\n// time and we only need to check and escape value.\r\nfunction ssrRenderAttr(key, value) {\r\n    if (!isRenderableValue(value)) {\r\n        return ``;\r\n    }\r\n    return ` ${key}=\"${shared.escapeHtml(value)}\"`;\r\n}\r\nfunction isRenderableValue(value) {\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    const type = typeof value;\r\n    return type === 'string' || type === 'number' || type === 'boolean';\r\n}\r\nfunction ssrRenderClass(raw) {\r\n    return shared.escapeHtml(shared.normalizeClass(raw));\r\n}\r\nfunction ssrRenderStyle(raw) {\r\n    if (!raw) {\r\n        return '';\r\n    }\r\n    if (shared.isString(raw)) {\r\n        return shared.escapeHtml(raw);\r\n    }\r\n    const styles = shared.normalizeStyle(raw);\r\n    return shared.escapeHtml(shared.stringifyStyle(styles));\r\n}\n\nconst compileCache = Object.create(null);\r\nfunction ssrCompile(template, instance) {\r\n    // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\r\n    const Component = instance.type;\r\n    const { isCustomElement, compilerOptions } = instance.appContext.config;\r\n    const { delimiters, compilerOptions: componentCompilerOptions } = Component;\r\n    const finalCompilerOptions = shared.extend(shared.extend({\r\n        isCustomElement,\r\n        delimiters\r\n    }, compilerOptions), componentCompilerOptions);\r\n    finalCompilerOptions.isCustomElement =\r\n        finalCompilerOptions.isCustomElement || shared.NO;\r\n    finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || shared.NO;\r\n    const cacheKey = JSON.stringify({\r\n        template,\r\n        compilerOptions: finalCompilerOptions\r\n    }, (key, value) => {\r\n        return shared.isFunction(value) ? value.toString() : value;\r\n    });\r\n    const cached = compileCache[cacheKey];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    finalCompilerOptions.onError = (err) => {\r\n        {\r\n            throw err;\r\n        }\r\n    };\r\n    const { code } = compilerSsr.compile(template, finalCompilerOptions);\r\n    return (compileCache[cacheKey] = Function('require', code)(require));\r\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\r\n    parentPush('<!--teleport start-->');\r\n    let teleportContent;\r\n    if (disabled) {\r\n        contentRenderFn(parentPush);\r\n        teleportContent = `<!---->`;\r\n    }\r\n    else {\r\n        const { getBuffer, push } = createBuffer();\r\n        contentRenderFn(push);\r\n        push(`<!---->`); // teleport end anchor\r\n        teleportContent = getBuffer();\r\n    }\r\n    const context = parentComponent.appContext.provides[vue.ssrContextKey];\r\n    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\r\n    if (teleportBuffers[target]) {\r\n        teleportBuffers[target].push(teleportContent);\r\n    }\r\n    else {\r\n        teleportBuffers[target] = [teleportContent];\r\n    }\r\n    parentPush('<!--teleport end-->');\r\n}\n\nconst { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = vue.ssrUtils;\r\n// Each component has a buffer array.\r\n// A buffer array can contain one of the following:\r\n// - plain string\r\n// - A resolved buffer (recursive arrays of strings that can be unrolled\r\n//   synchronously)\r\n// - An async buffer (a Promise that resolves to a resolved buffer)\r\nfunction createBuffer() {\r\n    let appendable = false;\r\n    const buffer = [];\r\n    return {\r\n        getBuffer() {\r\n            // Return static buffer and await on items during unroll stage\r\n            return buffer;\r\n        },\r\n        push(item) {\r\n            const isStringItem = shared.isString(item);\r\n            if (appendable && isStringItem) {\r\n                buffer[buffer.length - 1] += item;\r\n            }\r\n            else {\r\n                buffer.push(item);\r\n            }\r\n            appendable = isStringItem;\r\n            if (shared.isPromise(item) || (shared.isArray(item) && item.hasAsync)) {\r\n                // promise, or child buffer with async, mark as async.\r\n                // this allows skipping unnecessary await ticks during unroll stage\r\n                buffer.hasAsync = true;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\r\n    const instance = createComponentInstance(vnode, parentComponent, null);\r\n    const res = setupComponent(instance, true /* isSSR */);\r\n    const hasAsyncSetup = shared.isPromise(res);\r\n    const prefetches = instance.sp; /* LifecycleHooks.SERVER_PREFETCH */\r\n    if (hasAsyncSetup || prefetches) {\r\n        let p = hasAsyncSetup\r\n            ? res\r\n            : Promise.resolve();\r\n        if (prefetches) {\r\n            p = p\r\n                .then(() => Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy))))\r\n                // Note: error display is already done by the wrapped lifecycle hook function.\r\n                .catch(() => { });\r\n        }\r\n        return p.then(() => renderComponentSubTree(instance, slotScopeId));\r\n    }\r\n    else {\r\n        return renderComponentSubTree(instance, slotScopeId);\r\n    }\r\n}\r\nfunction renderComponentSubTree(instance, slotScopeId) {\r\n    const comp = instance.type;\r\n    const { getBuffer, push } = createBuffer();\r\n    if (shared.isFunction(comp)) {\r\n        renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\r\n    }\r\n    else {\r\n        if ((!instance.render || instance.render === shared.NOOP) &&\r\n            !instance.ssrRender &&\r\n            !comp.ssrRender &&\r\n            shared.isString(comp.template)) {\r\n            comp.ssrRender = ssrCompile(comp.template, instance);\r\n        }\r\n        // perf: enable caching of computed getters during render\r\n        // since there cannot be state mutations during render.\r\n        for (const e of instance.scope.effects) {\r\n            if (e.computed)\r\n                e.computed._cacheable = true;\r\n        }\r\n        const ssrRender = instance.ssrRender || comp.ssrRender;\r\n        if (ssrRender) {\r\n            // optimized\r\n            // resolve fallthrough attrs\r\n            let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;\r\n            let hasCloned = false;\r\n            let cur = instance;\r\n            while (true) {\r\n                const scopeId = cur.vnode.scopeId;\r\n                if (scopeId) {\r\n                    if (!hasCloned) {\r\n                        attrs = Object.assign({}, attrs);\r\n                        hasCloned = true;\r\n                    }\r\n                    attrs[scopeId] = '';\r\n                }\r\n                const parent = cur.parent;\r\n                if (parent && parent.subTree && parent.subTree === cur.vnode) {\r\n                    // parent is a non-SSR compiled component and is rendering this\r\n                    // component as root. inherit its scopeId if present.\r\n                    cur = parent;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            if (slotScopeId) {\r\n                if (!hasCloned)\r\n                    attrs = Object.assign({}, attrs);\r\n                attrs[slotScopeId.trim()] = '';\r\n            }\r\n            // set current rendering instance for asset resolution\r\n            const prev = setCurrentRenderingInstance(instance);\r\n            ssrRender(instance.proxy, push, instance, attrs, \r\n            // compiler-optimized bindings\r\n            instance.props, instance.setupState, instance.data, instance.ctx);\r\n            setCurrentRenderingInstance(prev);\r\n        }\r\n        else if (instance.render && instance.render !== shared.NOOP) {\r\n            renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\r\n        }\r\n        else {\r\n            vue.warn(`Component ${comp.name ? `${comp.name} ` : ``} is missing template or render function.`);\r\n            push(`<!---->`);\r\n        }\r\n    }\r\n    return getBuffer();\r\n}\r\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const { type, shapeFlag, children } = vnode;\r\n    switch (type) {\r\n        case vue.Text:\r\n            push(shared.escapeHtml(children));\r\n            break;\r\n        case vue.Comment:\r\n            push(children ? `<!--${shared.escapeHtmlComment(children)}-->` : `<!---->`);\r\n            break;\r\n        case vue.Static:\r\n            push(children);\r\n            break;\r\n        case vue.Fragment:\r\n            if (vnode.slotScopeIds) {\r\n                slotScopeId =\r\n                    (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ');\r\n            }\r\n            push(`<!--[-->`); // open\r\n            renderVNodeChildren(push, children, parentComponent, slotScopeId);\r\n            push(`<!--]-->`); // close\r\n            break;\r\n        default:\r\n            if (shapeFlag & 1 /* ELEMENT */) {\r\n                renderElementVNode(push, vnode, parentComponent, slotScopeId);\r\n            }\r\n            else if (shapeFlag & 6 /* COMPONENT */) {\r\n                push(renderComponentVNode(vnode, parentComponent, slotScopeId));\r\n            }\r\n            else if (shapeFlag & 64 /* TELEPORT */) {\r\n                renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\r\n            }\r\n            else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\r\n            }\r\n            else {\r\n                vue.warn('[@vue/server-renderer] Invalid VNode type:', type, `(${typeof type})`);\r\n            }\r\n    }\r\n}\r\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\r\n    }\r\n}\r\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const tag = vnode.type;\r\n    let { props, children, shapeFlag, scopeId, dirs } = vnode;\r\n    let openTag = `<${tag}`;\r\n    if (dirs) {\r\n        props = applySSRDirectives(vnode, props, dirs);\r\n    }\r\n    if (props) {\r\n        openTag += ssrRenderAttrs(props, tag);\r\n    }\r\n    if (scopeId) {\r\n        openTag += ` ${scopeId}`;\r\n    }\r\n    // inherit parent chain scope id if this is the root node\r\n    let curParent = parentComponent;\r\n    let curVnode = vnode;\r\n    while (curParent && curVnode === curParent.subTree) {\r\n        curVnode = curParent.vnode;\r\n        if (curVnode.scopeId) {\r\n            openTag += ` ${curVnode.scopeId}`;\r\n        }\r\n        curParent = curParent.parent;\r\n    }\r\n    if (slotScopeId) {\r\n        openTag += ` ${slotScopeId}`;\r\n    }\r\n    push(openTag + `>`);\r\n    if (!shared.isVoidTag(tag)) {\r\n        let hasChildrenOverride = false;\r\n        if (props) {\r\n            if (props.innerHTML) {\r\n                hasChildrenOverride = true;\r\n                push(props.innerHTML);\r\n            }\r\n            else if (props.textContent) {\r\n                hasChildrenOverride = true;\r\n                push(shared.escapeHtml(props.textContent));\r\n            }\r\n            else if (tag === 'textarea' && props.value) {\r\n                hasChildrenOverride = true;\r\n                push(shared.escapeHtml(props.value));\r\n            }\r\n        }\r\n        if (!hasChildrenOverride) {\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                push(shared.escapeHtml(children));\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                renderVNodeChildren(push, children, parentComponent, slotScopeId);\r\n            }\r\n        }\r\n        push(`</${tag}>`);\r\n    }\r\n}\r\nfunction applySSRDirectives(vnode, rawProps, dirs) {\r\n    const toMerge = [];\r\n    for (let i = 0; i < dirs.length; i++) {\r\n        const binding = dirs[i];\r\n        const { dir: { getSSRProps } } = binding;\r\n        if (getSSRProps) {\r\n            const props = getSSRProps(binding, vnode);\r\n            if (props)\r\n                toMerge.push(props);\r\n        }\r\n    }\r\n    return vue.mergeProps(rawProps || {}, ...toMerge);\r\n}\r\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const target = vnode.props && vnode.props.to;\r\n    const disabled = vnode.props && vnode.props.disabled;\r\n    if (!target) {\r\n        vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);\r\n        return [];\r\n    }\r\n    if (!shared.isString(target)) {\r\n        vue.warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);\r\n        return [];\r\n    }\r\n    ssrRenderTeleport(push, push => {\r\n        renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);\r\n    }, target, disabled || disabled === '', parentComponent);\r\n}\n\nconst { isVNode } = vue.ssrUtils;\r\nfunction unrollBuffer(buffer) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (buffer.hasAsync) {\r\n            let ret = '';\r\n            for (let i = 0; i < buffer.length; i++) {\r\n                let item = buffer[i];\r\n                if (shared.isPromise(item)) {\r\n                    item = yield item;\r\n                }\r\n                if (shared.isString(item)) {\r\n                    ret += item;\r\n                }\r\n                else {\r\n                    ret += yield unrollBuffer(item);\r\n                }\r\n            }\r\n            return ret;\r\n        }\r\n        else {\r\n            // sync buffer can be more efficiently unrolled without unnecessary await\r\n            // ticks\r\n            return unrollBufferSync(buffer);\r\n        }\r\n    });\r\n}\r\nfunction unrollBufferSync(buffer) {\r\n    let ret = '';\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        let item = buffer[i];\r\n        if (shared.isString(item)) {\r\n            ret += item;\r\n        }\r\n        else {\r\n            // since this is a sync buffer, child buffers are never promises\r\n            ret += unrollBufferSync(item);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction renderToString(input, context = {}) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (isVNode(input)) {\r\n            // raw vnode, wrap with app (for context)\r\n            return renderToString(vue.createApp({ render: () => input }), context);\r\n        }\r\n        // rendering an app\r\n        const vnode = vue.createVNode(input._component, input._props);\r\n        vnode.appContext = input._context;\r\n        // provide the ssr context to the tree\r\n        input.provide(vue.ssrContextKey, context);\r\n        const buffer = yield renderComponentVNode(vnode);\r\n        yield resolveTeleports(context);\r\n        return unrollBuffer(buffer);\r\n    });\r\n}\r\nfunction resolveTeleports(context) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (context.__teleportBuffers) {\r\n            context.teleports = context.teleports || {};\r\n            for (const key in context.__teleportBuffers) {\r\n                // note: it's OK to await sequentially here because the Promises were\r\n                // created eagerly in parallel.\r\n                context.teleports[key] = yield unrollBuffer((yield Promise.all(context.__teleportBuffers[key])));\r\n            }\r\n        }\r\n    });\r\n}\n\nconst { isVNode: isVNode$1 } = vue.ssrUtils;\r\nfunction unrollBuffer$1(buffer, stream) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (buffer.hasAsync) {\r\n            for (let i = 0; i < buffer.length; i++) {\r\n                let item = buffer[i];\r\n                if (shared.isPromise(item)) {\r\n                    item = yield item;\r\n                }\r\n                if (shared.isString(item)) {\r\n                    stream.push(item);\r\n                }\r\n                else {\r\n                    yield unrollBuffer$1(item, stream);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // sync buffer can be more efficiently unrolled without unnecessary await\r\n            // ticks\r\n            unrollBufferSync$1(buffer, stream);\r\n        }\r\n    });\r\n}\r\nfunction unrollBufferSync$1(buffer, stream) {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        let item = buffer[i];\r\n        if (shared.isString(item)) {\r\n            stream.push(item);\r\n        }\r\n        else {\r\n            // since this is a sync buffer, child buffers are never promises\r\n            unrollBufferSync$1(item, stream);\r\n        }\r\n    }\r\n}\r\nfunction renderToSimpleStream(input, context, stream) {\r\n    if (isVNode$1(input)) {\r\n        // raw vnode, wrap with app (for context)\r\n        return renderToSimpleStream(vue.createApp({ render: () => input }), context, stream);\r\n    }\r\n    // rendering an app\r\n    const vnode = vue.createVNode(input._component, input._props);\r\n    vnode.appContext = input._context;\r\n    // provide the ssr context to the tree\r\n    input.provide(vue.ssrContextKey, context);\r\n    Promise.resolve(renderComponentVNode(vnode))\r\n        .then(buffer => unrollBuffer$1(buffer, stream))\r\n        .then(() => stream.push(null))\r\n        .catch(error => {\r\n        stream.destroy(error);\r\n    });\r\n    return stream;\r\n}\r\n/**\r\n * @deprecated\r\n */\r\nfunction renderToStream(input, context = {}) {\r\n    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);\r\n    return renderToNodeStream(input, context);\r\n}\r\nfunction renderToNodeStream(input, context = {}) {\r\n    const stream = new (require('stream').Readable)()\r\n        ;\r\n    if (!stream) {\r\n        throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). ` +\r\n            `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\r\n            `instance instead.`);\r\n    }\r\n    return renderToSimpleStream(input, context, stream);\r\n}\r\nfunction pipeToNodeWritable(input, context = {}, writable) {\r\n    renderToSimpleStream(input, context, {\r\n        push(content) {\r\n            if (content != null) {\r\n                writable.write(content);\r\n            }\r\n            else {\r\n                writable.end();\r\n            }\r\n        },\r\n        destroy(err) {\r\n            writable.destroy(err);\r\n        }\r\n    });\r\n}\r\nfunction renderToWebStream(input, context = {}) {\r\n    if (typeof ReadableStream !== 'function') {\r\n        throw new Error(`ReadableStream constructor is not available in the global scope. ` +\r\n            `If the target environment does support web streams, consider using ` +\r\n            `pipeToWebWritable() with an existing WritableStream instance instead.`);\r\n    }\r\n    const encoder = new TextEncoder();\r\n    let cancelled = false;\r\n    return new ReadableStream({\r\n        start(controller) {\r\n            renderToSimpleStream(input, context, {\r\n                push(content) {\r\n                    if (cancelled)\r\n                        return;\r\n                    if (content != null) {\r\n                        controller.enqueue(encoder.encode(content));\r\n                    }\r\n                    else {\r\n                        controller.close();\r\n                    }\r\n                },\r\n                destroy(err) {\r\n                    controller.error(err);\r\n                }\r\n            });\r\n        },\r\n        cancel() {\r\n            cancelled = true;\r\n        }\r\n    });\r\n}\r\nfunction pipeToWebWritable(input, context = {}, writable) {\r\n    const writer = writable.getWriter();\r\n    const encoder = new TextEncoder();\r\n    // #4287 CloudFlare workers do not implement `ready` property\r\n    let hasReady = false;\r\n    try {\r\n        hasReady = shared.isPromise(writer.ready);\r\n    }\r\n    catch (e) { }\r\n    renderToSimpleStream(input, context, {\r\n        push(content) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                if (hasReady) {\r\n                    yield writer.ready;\r\n                }\r\n                if (content != null) {\r\n                    return writer.write(encoder.encode(content));\r\n                }\r\n                else {\r\n                    return writer.close();\r\n                }\r\n            });\r\n        },\r\n        destroy(err) {\r\n            // TODO better error handling?\r\n            console.log(err);\r\n            writer.close();\r\n        }\r\n    });\r\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\r\n    return renderComponentVNode(vue.createVNode(comp, props, children), parentComponent, slotScopeId);\r\n}\n\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\r\n    // template-compiled slots are always rendered as fragments\r\n    push(`<!--[-->`);\r\n    const slotFn = slots[slotName];\r\n    if (slotFn) {\r\n        const slotBuffer = [];\r\n        const bufferedPush = (item) => {\r\n            slotBuffer.push(item);\r\n        };\r\n        const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? ' ' + slotScopeId : '');\r\n        if (shared.isArray(ret)) {\r\n            // normal slot\r\n            renderVNodeChildren(push, ret, parentComponent, slotScopeId);\r\n        }\r\n        else {\r\n            // ssr slot.\r\n            // check if the slot renders all comments, in which case use the fallback\r\n            let isEmptySlot = true;\r\n            for (let i = 0; i < slotBuffer.length; i++) {\r\n                if (!isComment(slotBuffer[i])) {\r\n                    isEmptySlot = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isEmptySlot) {\r\n                if (fallbackRenderFn) {\r\n                    fallbackRenderFn();\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < slotBuffer.length; i++) {\r\n                    push(slotBuffer[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (fallbackRenderFn) {\r\n        fallbackRenderFn();\r\n    }\r\n    push(`<!--]-->`);\r\n}\r\nconst commentRE = /^<!--.*-->$/;\r\nfunction isComment(item) {\r\n    return typeof item === 'string' && commentRE.test(item);\r\n}\n\nfunction ssrInterpolate(value) {\r\n    return shared.escapeHtml(shared.toDisplayString(value));\r\n}\n\nfunction ssrRenderList(source, renderItem) {\r\n    if (shared.isArray(source) || shared.isString(source)) {\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        for (let i = 0; i < source; i++) {\r\n            renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (shared.isObject(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            const arr = Array.from(source);\r\n            for (let i = 0, l = arr.length; i < l; i++) {\r\n                renderItem(arr[i], i);\r\n            }\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n}\n\nfunction ssrRenderSuspense(push, { default: renderContent }) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (renderContent) {\r\n            renderContent();\r\n        }\r\n        else {\r\n            push(`<!---->`);\r\n        }\r\n    });\r\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\r\n    if (typeof dir !== 'function' && dir.getSSRProps) {\r\n        return (dir.getSSRProps({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: undefined,\r\n            arg,\r\n            modifiers\r\n        }, null) || {});\r\n    }\r\n    return {};\r\n}\n\nconst ssrLooseEqual = shared.looseEqual;\r\nfunction ssrLooseContain(arr, value) {\r\n    return shared.looseIndexOf(arr, value) > -1;\r\n}\r\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\r\nfunction ssrRenderDynamicModel(type, model, value) {\r\n    switch (type) {\r\n        case 'radio':\r\n            return shared.looseEqual(model, value) ? ' checked' : '';\r\n        case 'checkbox':\r\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\r\n                ? ' checked'\r\n                : '';\r\n        default:\r\n            // text types\r\n            return ssrRenderAttr('value', model);\r\n    }\r\n}\r\n// for <input v-bind=\"obj\" v-model=\"model\">\r\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\r\n    const { type, value } = existingProps;\r\n    switch (type) {\r\n        case 'radio':\r\n            return shared.looseEqual(model, value) ? { checked: true } : null;\r\n        case 'checkbox':\r\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\r\n                ? { checked: true }\r\n                : null;\r\n        default:\r\n            // text types\r\n            return { value: model };\r\n    }\r\n}\n\nvue.initDirectivesForSSR();\n\nexports.ssrIncludeBooleanAttr = shared.includeBooleanAttr;\nexports.pipeToNodeWritable = pipeToNodeWritable;\nexports.pipeToWebWritable = pipeToWebWritable;\nexports.renderToNodeStream = renderToNodeStream;\nexports.renderToSimpleStream = renderToSimpleStream;\nexports.renderToStream = renderToStream;\nexports.renderToString = renderToString;\nexports.renderToWebStream = renderToWebStream;\nexports.ssrGetDirectiveProps = ssrGetDirectiveProps;\nexports.ssrGetDynamicModelProps = ssrGetDynamicModelProps;\nexports.ssrInterpolate = ssrInterpolate;\nexports.ssrLooseContain = ssrLooseContain;\nexports.ssrLooseEqual = ssrLooseEqual;\nexports.ssrRenderAttr = ssrRenderAttr;\nexports.ssrRenderAttrs = ssrRenderAttrs;\nexports.ssrRenderClass = ssrRenderClass;\nexports.ssrRenderComponent = ssrRenderComponent;\nexports.ssrRenderDynamicAttr = ssrRenderDynamicAttr;\nexports.ssrRenderDynamicModel = ssrRenderDynamicModel;\nexports.ssrRenderList = ssrRenderList;\nexports.ssrRenderSlot = ssrRenderSlot;\nexports.ssrRenderStyle = ssrRenderStyle;\nexports.ssrRenderSuspense = ssrRenderSuspense;\nexports.ssrRenderTeleport = ssrRenderTeleport;\nexports.ssrRenderVNode = renderVNode;\n","\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar vue = require('vue');\nvar shared = require('@vue/shared');\nvar compilerSsr = require('@vue/compiler-ssr');\n\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\n\n// leading comma for empty string \"\"\r\nconst shouldIgnoreProp = shared.makeMap(`,key,ref,innerHTML,textContent`);\r\nfunction ssrRenderAttrs(props, tag) {\r\n    let ret = '';\r\n    for (const key in props) {\r\n        if (shouldIgnoreProp(key) ||\r\n            shared.isOn(key) ||\r\n            (tag === 'textarea' && key === 'value')) {\r\n            continue;\r\n        }\r\n        const value = props[key];\r\n        if (key === 'class') {\r\n            ret += ` class=\"${ssrRenderClass(value)}\"`;\r\n        }\r\n        else if (key === 'style') {\r\n            ret += ` style=\"${ssrRenderStyle(value)}\"`;\r\n        }\r\n        else {\r\n            ret += ssrRenderDynamicAttr(key, value, tag);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\n// render an attr with dynamic (unknown) key.\r\nfunction ssrRenderDynamicAttr(key, value, tag) {\r\n    if (!isRenderableValue(value)) {\r\n        return ``;\r\n    }\r\n    const attrKey = tag && tag.indexOf('-') > 0\r\n        ? key // preserve raw name on custom elements\r\n        : shared.propsToAttrMap[key] || key.toLowerCase();\r\n    if (shared.isBooleanAttr(attrKey)) {\r\n        return shared.includeBooleanAttr(value) ? ` ${attrKey}` : ``;\r\n    }\r\n    else if (shared.isSSRSafeAttrName(attrKey)) {\r\n        return value === '' ? ` ${attrKey}` : ` ${attrKey}=\"${shared.escapeHtml(value)}\"`;\r\n    }\r\n    else {\r\n        console.warn(`[@vue/server-renderer] Skipped rendering unsafe attribute name: ${attrKey}`);\r\n        return ``;\r\n    }\r\n}\r\n// Render a v-bind attr with static key. The key is pre-processed at compile\r\n// time and we only need to check and escape value.\r\nfunction ssrRenderAttr(key, value) {\r\n    if (!isRenderableValue(value)) {\r\n        return ``;\r\n    }\r\n    return ` ${key}=\"${shared.escapeHtml(value)}\"`;\r\n}\r\nfunction isRenderableValue(value) {\r\n    if (value == null) {\r\n        return false;\r\n    }\r\n    const type = typeof value;\r\n    return type === 'string' || type === 'number' || type === 'boolean';\r\n}\r\nfunction ssrRenderClass(raw) {\r\n    return shared.escapeHtml(shared.normalizeClass(raw));\r\n}\r\nfunction ssrRenderStyle(raw) {\r\n    if (!raw) {\r\n        return '';\r\n    }\r\n    if (shared.isString(raw)) {\r\n        return shared.escapeHtml(raw);\r\n    }\r\n    const styles = shared.normalizeStyle(raw);\r\n    return shared.escapeHtml(shared.stringifyStyle(styles));\r\n}\n\nconst compileCache = Object.create(null);\r\nfunction ssrCompile(template, instance) {\r\n    // TODO: This is copied from runtime-core/src/component.ts and should probably be refactored\r\n    const Component = instance.type;\r\n    const { isCustomElement, compilerOptions } = instance.appContext.config;\r\n    const { delimiters, compilerOptions: componentCompilerOptions } = Component;\r\n    const finalCompilerOptions = shared.extend(shared.extend({\r\n        isCustomElement,\r\n        delimiters\r\n    }, compilerOptions), componentCompilerOptions);\r\n    finalCompilerOptions.isCustomElement =\r\n        finalCompilerOptions.isCustomElement || shared.NO;\r\n    finalCompilerOptions.isNativeTag = finalCompilerOptions.isNativeTag || shared.NO;\r\n    const cacheKey = JSON.stringify({\r\n        template,\r\n        compilerOptions: finalCompilerOptions\r\n    }, (key, value) => {\r\n        return shared.isFunction(value) ? value.toString() : value;\r\n    });\r\n    const cached = compileCache[cacheKey];\r\n    if (cached) {\r\n        return cached;\r\n    }\r\n    finalCompilerOptions.onError = (err) => {\r\n        {\r\n            const message = `[@vue/server-renderer] Template compilation error: ${err.message}`;\r\n            const codeFrame = err.loc &&\r\n                shared.generateCodeFrame(template, err.loc.start.offset, err.loc.end.offset);\r\n            vue.warn(codeFrame ? `${message}\\n${codeFrame}` : message);\r\n        }\r\n    };\r\n    const { code } = compilerSsr.compile(template, finalCompilerOptions);\r\n    return (compileCache[cacheKey] = Function('require', code)(require));\r\n}\n\nfunction ssrRenderTeleport(parentPush, contentRenderFn, target, disabled, parentComponent) {\r\n    parentPush('<!--teleport start-->');\r\n    let teleportContent;\r\n    if (disabled) {\r\n        contentRenderFn(parentPush);\r\n        teleportContent = `<!---->`;\r\n    }\r\n    else {\r\n        const { getBuffer, push } = createBuffer();\r\n        contentRenderFn(push);\r\n        push(`<!---->`); // teleport end anchor\r\n        teleportContent = getBuffer();\r\n    }\r\n    const context = parentComponent.appContext.provides[vue.ssrContextKey];\r\n    const teleportBuffers = context.__teleportBuffers || (context.__teleportBuffers = {});\r\n    if (teleportBuffers[target]) {\r\n        teleportBuffers[target].push(teleportContent);\r\n    }\r\n    else {\r\n        teleportBuffers[target] = [teleportContent];\r\n    }\r\n    parentPush('<!--teleport end-->');\r\n}\n\nconst { createComponentInstance, setCurrentRenderingInstance, setupComponent, renderComponentRoot, normalizeVNode } = vue.ssrUtils;\r\n// Each component has a buffer array.\r\n// A buffer array can contain one of the following:\r\n// - plain string\r\n// - A resolved buffer (recursive arrays of strings that can be unrolled\r\n//   synchronously)\r\n// - An async buffer (a Promise that resolves to a resolved buffer)\r\nfunction createBuffer() {\r\n    let appendable = false;\r\n    const buffer = [];\r\n    return {\r\n        getBuffer() {\r\n            // Return static buffer and await on items during unroll stage\r\n            return buffer;\r\n        },\r\n        push(item) {\r\n            const isStringItem = shared.isString(item);\r\n            if (appendable && isStringItem) {\r\n                buffer[buffer.length - 1] += item;\r\n            }\r\n            else {\r\n                buffer.push(item);\r\n            }\r\n            appendable = isStringItem;\r\n            if (shared.isPromise(item) || (shared.isArray(item) && item.hasAsync)) {\r\n                // promise, or child buffer with async, mark as async.\r\n                // this allows skipping unnecessary await ticks during unroll stage\r\n                buffer.hasAsync = true;\r\n            }\r\n        }\r\n    };\r\n}\r\nfunction renderComponentVNode(vnode, parentComponent = null, slotScopeId) {\r\n    const instance = createComponentInstance(vnode, parentComponent, null);\r\n    const res = setupComponent(instance, true /* isSSR */);\r\n    const hasAsyncSetup = shared.isPromise(res);\r\n    const prefetches = instance.sp; /* LifecycleHooks.SERVER_PREFETCH */\r\n    if (hasAsyncSetup || prefetches) {\r\n        let p = hasAsyncSetup\r\n            ? res\r\n            : Promise.resolve();\r\n        if (prefetches) {\r\n            p = p\r\n                .then(() => Promise.all(prefetches.map(prefetch => prefetch.call(instance.proxy))))\r\n                // Note: error display is already done by the wrapped lifecycle hook function.\r\n                .catch(() => { });\r\n        }\r\n        return p.then(() => renderComponentSubTree(instance, slotScopeId));\r\n    }\r\n    else {\r\n        return renderComponentSubTree(instance, slotScopeId);\r\n    }\r\n}\r\nfunction renderComponentSubTree(instance, slotScopeId) {\r\n    const comp = instance.type;\r\n    const { getBuffer, push } = createBuffer();\r\n    if (shared.isFunction(comp)) {\r\n        renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\r\n    }\r\n    else {\r\n        if ((!instance.render || instance.render === shared.NOOP) &&\r\n            !instance.ssrRender &&\r\n            !comp.ssrRender &&\r\n            shared.isString(comp.template)) {\r\n            comp.ssrRender = ssrCompile(comp.template, instance);\r\n        }\r\n        // perf: enable caching of computed getters during render\r\n        // since there cannot be state mutations during render.\r\n        for (const e of instance.scope.effects) {\r\n            if (e.computed)\r\n                e.computed._cacheable = true;\r\n        }\r\n        const ssrRender = instance.ssrRender || comp.ssrRender;\r\n        if (ssrRender) {\r\n            // optimized\r\n            // resolve fallthrough attrs\r\n            let attrs = instance.inheritAttrs !== false ? instance.attrs : undefined;\r\n            let hasCloned = false;\r\n            let cur = instance;\r\n            while (true) {\r\n                const scopeId = cur.vnode.scopeId;\r\n                if (scopeId) {\r\n                    if (!hasCloned) {\r\n                        attrs = Object.assign({}, attrs);\r\n                        hasCloned = true;\r\n                    }\r\n                    attrs[scopeId] = '';\r\n                }\r\n                const parent = cur.parent;\r\n                if (parent && parent.subTree && parent.subTree === cur.vnode) {\r\n                    // parent is a non-SSR compiled component and is rendering this\r\n                    // component as root. inherit its scopeId if present.\r\n                    cur = parent;\r\n                }\r\n                else {\r\n                    break;\r\n                }\r\n            }\r\n            if (slotScopeId) {\r\n                if (!hasCloned)\r\n                    attrs = Object.assign({}, attrs);\r\n                attrs[slotScopeId.trim()] = '';\r\n            }\r\n            // set current rendering instance for asset resolution\r\n            const prev = setCurrentRenderingInstance(instance);\r\n            ssrRender(instance.proxy, push, instance, attrs, \r\n            // compiler-optimized bindings\r\n            instance.props, instance.setupState, instance.data, instance.ctx);\r\n            setCurrentRenderingInstance(prev);\r\n        }\r\n        else if (instance.render && instance.render !== shared.NOOP) {\r\n            renderVNode(push, (instance.subTree = renderComponentRoot(instance)), instance, slotScopeId);\r\n        }\r\n        else {\r\n            vue.warn(`Component ${comp.name ? `${comp.name} ` : ``} is missing template or render function.`);\r\n            push(`<!---->`);\r\n        }\r\n    }\r\n    return getBuffer();\r\n}\r\nfunction renderVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const { type, shapeFlag, children } = vnode;\r\n    switch (type) {\r\n        case vue.Text:\r\n            push(shared.escapeHtml(children));\r\n            break;\r\n        case vue.Comment:\r\n            push(children ? `<!--${shared.escapeHtmlComment(children)}-->` : `<!---->`);\r\n            break;\r\n        case vue.Static:\r\n            push(children);\r\n            break;\r\n        case vue.Fragment:\r\n            if (vnode.slotScopeIds) {\r\n                slotScopeId =\r\n                    (slotScopeId ? slotScopeId + ' ' : '') + vnode.slotScopeIds.join(' ');\r\n            }\r\n            push(`<!--[-->`); // open\r\n            renderVNodeChildren(push, children, parentComponent, slotScopeId);\r\n            push(`<!--]-->`); // close\r\n            break;\r\n        default:\r\n            if (shapeFlag & 1 /* ELEMENT */) {\r\n                renderElementVNode(push, vnode, parentComponent, slotScopeId);\r\n            }\r\n            else if (shapeFlag & 6 /* COMPONENT */) {\r\n                push(renderComponentVNode(vnode, parentComponent, slotScopeId));\r\n            }\r\n            else if (shapeFlag & 64 /* TELEPORT */) {\r\n                renderTeleportVNode(push, vnode, parentComponent, slotScopeId);\r\n            }\r\n            else if (shapeFlag & 128 /* SUSPENSE */) {\r\n                renderVNode(push, vnode.ssContent, parentComponent, slotScopeId);\r\n            }\r\n            else {\r\n                vue.warn('[@vue/server-renderer] Invalid VNode type:', type, `(${typeof type})`);\r\n            }\r\n    }\r\n}\r\nfunction renderVNodeChildren(push, children, parentComponent, slotScopeId) {\r\n    for (let i = 0; i < children.length; i++) {\r\n        renderVNode(push, normalizeVNode(children[i]), parentComponent, slotScopeId);\r\n    }\r\n}\r\nfunction renderElementVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const tag = vnode.type;\r\n    let { props, children, shapeFlag, scopeId, dirs } = vnode;\r\n    let openTag = `<${tag}`;\r\n    if (dirs) {\r\n        props = applySSRDirectives(vnode, props, dirs);\r\n    }\r\n    if (props) {\r\n        openTag += ssrRenderAttrs(props, tag);\r\n    }\r\n    if (scopeId) {\r\n        openTag += ` ${scopeId}`;\r\n    }\r\n    // inherit parent chain scope id if this is the root node\r\n    let curParent = parentComponent;\r\n    let curVnode = vnode;\r\n    while (curParent && curVnode === curParent.subTree) {\r\n        curVnode = curParent.vnode;\r\n        if (curVnode.scopeId) {\r\n            openTag += ` ${curVnode.scopeId}`;\r\n        }\r\n        curParent = curParent.parent;\r\n    }\r\n    if (slotScopeId) {\r\n        openTag += ` ${slotScopeId}`;\r\n    }\r\n    push(openTag + `>`);\r\n    if (!shared.isVoidTag(tag)) {\r\n        let hasChildrenOverride = false;\r\n        if (props) {\r\n            if (props.innerHTML) {\r\n                hasChildrenOverride = true;\r\n                push(props.innerHTML);\r\n            }\r\n            else if (props.textContent) {\r\n                hasChildrenOverride = true;\r\n                push(shared.escapeHtml(props.textContent));\r\n            }\r\n            else if (tag === 'textarea' && props.value) {\r\n                hasChildrenOverride = true;\r\n                push(shared.escapeHtml(props.value));\r\n            }\r\n        }\r\n        if (!hasChildrenOverride) {\r\n            if (shapeFlag & 8 /* TEXT_CHILDREN */) {\r\n                push(shared.escapeHtml(children));\r\n            }\r\n            else if (shapeFlag & 16 /* ARRAY_CHILDREN */) {\r\n                renderVNodeChildren(push, children, parentComponent, slotScopeId);\r\n            }\r\n        }\r\n        push(`</${tag}>`);\r\n    }\r\n}\r\nfunction applySSRDirectives(vnode, rawProps, dirs) {\r\n    const toMerge = [];\r\n    for (let i = 0; i < dirs.length; i++) {\r\n        const binding = dirs[i];\r\n        const { dir: { getSSRProps } } = binding;\r\n        if (getSSRProps) {\r\n            const props = getSSRProps(binding, vnode);\r\n            if (props)\r\n                toMerge.push(props);\r\n        }\r\n    }\r\n    return vue.mergeProps(rawProps || {}, ...toMerge);\r\n}\r\nfunction renderTeleportVNode(push, vnode, parentComponent, slotScopeId) {\r\n    const target = vnode.props && vnode.props.to;\r\n    const disabled = vnode.props && vnode.props.disabled;\r\n    if (!target) {\r\n        vue.warn(`[@vue/server-renderer] Teleport is missing target prop.`);\r\n        return [];\r\n    }\r\n    if (!shared.isString(target)) {\r\n        vue.warn(`[@vue/server-renderer] Teleport target must be a query selector string.`);\r\n        return [];\r\n    }\r\n    ssrRenderTeleport(push, push => {\r\n        renderVNodeChildren(push, vnode.children, parentComponent, slotScopeId);\r\n    }, target, disabled || disabled === '', parentComponent);\r\n}\n\nconst { isVNode } = vue.ssrUtils;\r\nfunction unrollBuffer(buffer) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (buffer.hasAsync) {\r\n            let ret = '';\r\n            for (let i = 0; i < buffer.length; i++) {\r\n                let item = buffer[i];\r\n                if (shared.isPromise(item)) {\r\n                    item = yield item;\r\n                }\r\n                if (shared.isString(item)) {\r\n                    ret += item;\r\n                }\r\n                else {\r\n                    ret += yield unrollBuffer(item);\r\n                }\r\n            }\r\n            return ret;\r\n        }\r\n        else {\r\n            // sync buffer can be more efficiently unrolled without unnecessary await\r\n            // ticks\r\n            return unrollBufferSync(buffer);\r\n        }\r\n    });\r\n}\r\nfunction unrollBufferSync(buffer) {\r\n    let ret = '';\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        let item = buffer[i];\r\n        if (shared.isString(item)) {\r\n            ret += item;\r\n        }\r\n        else {\r\n            // since this is a sync buffer, child buffers are never promises\r\n            ret += unrollBufferSync(item);\r\n        }\r\n    }\r\n    return ret;\r\n}\r\nfunction renderToString(input, context = {}) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (isVNode(input)) {\r\n            // raw vnode, wrap with app (for context)\r\n            return renderToString(vue.createApp({ render: () => input }), context);\r\n        }\r\n        // rendering an app\r\n        const vnode = vue.createVNode(input._component, input._props);\r\n        vnode.appContext = input._context;\r\n        // provide the ssr context to the tree\r\n        input.provide(vue.ssrContextKey, context);\r\n        const buffer = yield renderComponentVNode(vnode);\r\n        yield resolveTeleports(context);\r\n        return unrollBuffer(buffer);\r\n    });\r\n}\r\nfunction resolveTeleports(context) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (context.__teleportBuffers) {\r\n            context.teleports = context.teleports || {};\r\n            for (const key in context.__teleportBuffers) {\r\n                // note: it's OK to await sequentially here because the Promises were\r\n                // created eagerly in parallel.\r\n                context.teleports[key] = yield unrollBuffer((yield Promise.all(context.__teleportBuffers[key])));\r\n            }\r\n        }\r\n    });\r\n}\n\nconst { isVNode: isVNode$1 } = vue.ssrUtils;\r\nfunction unrollBuffer$1(buffer, stream) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (buffer.hasAsync) {\r\n            for (let i = 0; i < buffer.length; i++) {\r\n                let item = buffer[i];\r\n                if (shared.isPromise(item)) {\r\n                    item = yield item;\r\n                }\r\n                if (shared.isString(item)) {\r\n                    stream.push(item);\r\n                }\r\n                else {\r\n                    yield unrollBuffer$1(item, stream);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // sync buffer can be more efficiently unrolled without unnecessary await\r\n            // ticks\r\n            unrollBufferSync$1(buffer, stream);\r\n        }\r\n    });\r\n}\r\nfunction unrollBufferSync$1(buffer, stream) {\r\n    for (let i = 0; i < buffer.length; i++) {\r\n        let item = buffer[i];\r\n        if (shared.isString(item)) {\r\n            stream.push(item);\r\n        }\r\n        else {\r\n            // since this is a sync buffer, child buffers are never promises\r\n            unrollBufferSync$1(item, stream);\r\n        }\r\n    }\r\n}\r\nfunction renderToSimpleStream(input, context, stream) {\r\n    if (isVNode$1(input)) {\r\n        // raw vnode, wrap with app (for context)\r\n        return renderToSimpleStream(vue.createApp({ render: () => input }), context, stream);\r\n    }\r\n    // rendering an app\r\n    const vnode = vue.createVNode(input._component, input._props);\r\n    vnode.appContext = input._context;\r\n    // provide the ssr context to the tree\r\n    input.provide(vue.ssrContextKey, context);\r\n    Promise.resolve(renderComponentVNode(vnode))\r\n        .then(buffer => unrollBuffer$1(buffer, stream))\r\n        .then(() => stream.push(null))\r\n        .catch(error => {\r\n        stream.destroy(error);\r\n    });\r\n    return stream;\r\n}\r\n/**\r\n * @deprecated\r\n */\r\nfunction renderToStream(input, context = {}) {\r\n    console.warn(`[@vue/server-renderer] renderToStream is deprecated - use renderToNodeStream instead.`);\r\n    return renderToNodeStream(input, context);\r\n}\r\nfunction renderToNodeStream(input, context = {}) {\r\n    const stream = new (require('stream').Readable)()\r\n        ;\r\n    if (!stream) {\r\n        throw new Error(`ESM build of renderToStream() does not support renderToNodeStream(). ` +\r\n            `Use pipeToNodeWritable() with an existing Node.js Writable stream ` +\r\n            `instance instead.`);\r\n    }\r\n    return renderToSimpleStream(input, context, stream);\r\n}\r\nfunction pipeToNodeWritable(input, context = {}, writable) {\r\n    renderToSimpleStream(input, context, {\r\n        push(content) {\r\n            if (content != null) {\r\n                writable.write(content);\r\n            }\r\n            else {\r\n                writable.end();\r\n            }\r\n        },\r\n        destroy(err) {\r\n            writable.destroy(err);\r\n        }\r\n    });\r\n}\r\nfunction renderToWebStream(input, context = {}) {\r\n    if (typeof ReadableStream !== 'function') {\r\n        throw new Error(`ReadableStream constructor is not available in the global scope. ` +\r\n            `If the target environment does support web streams, consider using ` +\r\n            `pipeToWebWritable() with an existing WritableStream instance instead.`);\r\n    }\r\n    const encoder = new TextEncoder();\r\n    let cancelled = false;\r\n    return new ReadableStream({\r\n        start(controller) {\r\n            renderToSimpleStream(input, context, {\r\n                push(content) {\r\n                    if (cancelled)\r\n                        return;\r\n                    if (content != null) {\r\n                        controller.enqueue(encoder.encode(content));\r\n                    }\r\n                    else {\r\n                        controller.close();\r\n                    }\r\n                },\r\n                destroy(err) {\r\n                    controller.error(err);\r\n                }\r\n            });\r\n        },\r\n        cancel() {\r\n            cancelled = true;\r\n        }\r\n    });\r\n}\r\nfunction pipeToWebWritable(input, context = {}, writable) {\r\n    const writer = writable.getWriter();\r\n    const encoder = new TextEncoder();\r\n    // #4287 CloudFlare workers do not implement `ready` property\r\n    let hasReady = false;\r\n    try {\r\n        hasReady = shared.isPromise(writer.ready);\r\n    }\r\n    catch (e) { }\r\n    renderToSimpleStream(input, context, {\r\n        push(content) {\r\n            return __awaiter(this, void 0, void 0, function* () {\r\n                if (hasReady) {\r\n                    yield writer.ready;\r\n                }\r\n                if (content != null) {\r\n                    return writer.write(encoder.encode(content));\r\n                }\r\n                else {\r\n                    return writer.close();\r\n                }\r\n            });\r\n        },\r\n        destroy(err) {\r\n            // TODO better error handling?\r\n            console.log(err);\r\n            writer.close();\r\n        }\r\n    });\r\n}\n\nfunction ssrRenderComponent(comp, props = null, children = null, parentComponent = null, slotScopeId) {\r\n    return renderComponentVNode(vue.createVNode(comp, props, children), parentComponent, slotScopeId);\r\n}\n\nfunction ssrRenderSlot(slots, slotName, slotProps, fallbackRenderFn, push, parentComponent, slotScopeId) {\r\n    // template-compiled slots are always rendered as fragments\r\n    push(`<!--[-->`);\r\n    const slotFn = slots[slotName];\r\n    if (slotFn) {\r\n        const slotBuffer = [];\r\n        const bufferedPush = (item) => {\r\n            slotBuffer.push(item);\r\n        };\r\n        const ret = slotFn(slotProps, bufferedPush, parentComponent, slotScopeId ? ' ' + slotScopeId : '');\r\n        if (shared.isArray(ret)) {\r\n            // normal slot\r\n            renderVNodeChildren(push, ret, parentComponent, slotScopeId);\r\n        }\r\n        else {\r\n            // ssr slot.\r\n            // check if the slot renders all comments, in which case use the fallback\r\n            let isEmptySlot = true;\r\n            for (let i = 0; i < slotBuffer.length; i++) {\r\n                if (!isComment(slotBuffer[i])) {\r\n                    isEmptySlot = false;\r\n                    break;\r\n                }\r\n            }\r\n            if (isEmptySlot) {\r\n                if (fallbackRenderFn) {\r\n                    fallbackRenderFn();\r\n                }\r\n            }\r\n            else {\r\n                for (let i = 0; i < slotBuffer.length; i++) {\r\n                    push(slotBuffer[i]);\r\n                }\r\n            }\r\n        }\r\n    }\r\n    else if (fallbackRenderFn) {\r\n        fallbackRenderFn();\r\n    }\r\n    push(`<!--]-->`);\r\n}\r\nconst commentRE = /^<!--.*-->$/;\r\nfunction isComment(item) {\r\n    return typeof item === 'string' && commentRE.test(item);\r\n}\n\nfunction ssrInterpolate(value) {\r\n    return shared.escapeHtml(shared.toDisplayString(value));\r\n}\n\nfunction toRaw(observed) {\r\n    const raw = observed && observed[\"__v_raw\" /* RAW */];\r\n    return raw ? toRaw(raw) : observed;\r\n}\n\nfunction isRef(r) {\r\n    return !!(r && r.__v_isRef === true);\r\n}\n\nconst stack = [];\r\nfunction pushWarningContext(vnode) {\r\n    stack.push(vnode);\r\n}\r\nfunction popWarningContext() {\r\n    stack.pop();\r\n}\r\nfunction warn(msg, ...args) {\r\n    const instance = stack.length ? stack[stack.length - 1].component : null;\r\n    const appWarnHandler = instance && instance.appContext.config.warnHandler;\r\n    const trace = getComponentTrace();\r\n    if (appWarnHandler) {\r\n        callWithErrorHandling(appWarnHandler, instance, 11 /* APP_WARN_HANDLER */, [\r\n            msg + args.join(''),\r\n            instance && instance.proxy,\r\n            trace\r\n                .map(({ vnode }) => `at <${formatComponentName(instance, vnode.type)}>`)\r\n                .join('\\n'),\r\n            trace\r\n        ]);\r\n    }\r\n    else {\r\n        const warnArgs = [`[Vue warn]: ${msg}`, ...args];\r\n        /* istanbul ignore if */\r\n        if (trace.length &&\r\n            // avoid spamming console during tests\r\n            !false) {\r\n            warnArgs.push(`\\n`, ...formatTrace(trace));\r\n        }\r\n        console.warn(...warnArgs);\r\n    }\r\n}\r\nfunction getComponentTrace() {\r\n    let currentVNode = stack[stack.length - 1];\r\n    if (!currentVNode) {\r\n        return [];\r\n    }\r\n    // we can't just use the stack because it will be incomplete during updates\r\n    // that did not start from the root. Re-construct the parent chain using\r\n    // instance parent pointers.\r\n    const normalizedStack = [];\r\n    while (currentVNode) {\r\n        const last = normalizedStack[0];\r\n        if (last && last.vnode === currentVNode) {\r\n            last.recurseCount++;\r\n        }\r\n        else {\r\n            normalizedStack.push({\r\n                vnode: currentVNode,\r\n                recurseCount: 0\r\n            });\r\n        }\r\n        const parentInstance = currentVNode.component && currentVNode.component.parent;\r\n        currentVNode = parentInstance && parentInstance.vnode;\r\n    }\r\n    return normalizedStack;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatTrace(trace) {\r\n    const logs = [];\r\n    trace.forEach((entry, i) => {\r\n        logs.push(...(i === 0 ? [] : [`\\n`]), ...formatTraceEntry(entry));\r\n    });\r\n    return logs;\r\n}\r\nfunction formatTraceEntry({ vnode, recurseCount }) {\r\n    const postfix = recurseCount > 0 ? `... (${recurseCount} recursive calls)` : ``;\r\n    const isRoot = vnode.component ? vnode.component.parent == null : false;\r\n    const open = ` at <${formatComponentName(vnode.component, vnode.type, isRoot)}`;\r\n    const close = `>` + postfix;\r\n    return vnode.props\r\n        ? [open, ...formatProps(vnode.props), close]\r\n        : [open + close];\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProps(props) {\r\n    const res = [];\r\n    const keys = Object.keys(props);\r\n    keys.slice(0, 3).forEach(key => {\r\n        res.push(...formatProp(key, props[key]));\r\n    });\r\n    if (keys.length > 3) {\r\n        res.push(` ...`);\r\n    }\r\n    return res;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatProp(key, value, raw) {\r\n    if (shared.isString(value)) {\r\n        value = JSON.stringify(value);\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (typeof value === 'number' ||\r\n        typeof value === 'boolean' ||\r\n        value == null) {\r\n        return raw ? value : [`${key}=${value}`];\r\n    }\r\n    else if (isRef(value)) {\r\n        value = formatProp(key, toRaw(value.value), true);\r\n        return raw ? value : [`${key}=Ref<`, value, `>`];\r\n    }\r\n    else if (shared.isFunction(value)) {\r\n        return [`${key}=fn${value.name ? `<${value.name}>` : ``}`];\r\n    }\r\n    else {\r\n        value = toRaw(value);\r\n        return raw ? value : [`${key}=`, value];\r\n    }\r\n}\n\nconst ErrorTypeStrings = {\r\n    [\"sp\" /* SERVER_PREFETCH */]: 'serverPrefetch hook',\r\n    [\"bc\" /* BEFORE_CREATE */]: 'beforeCreate hook',\r\n    [\"c\" /* CREATED */]: 'created hook',\r\n    [\"bm\" /* BEFORE_MOUNT */]: 'beforeMount hook',\r\n    [\"m\" /* MOUNTED */]: 'mounted hook',\r\n    [\"bu\" /* BEFORE_UPDATE */]: 'beforeUpdate hook',\r\n    [\"u\" /* UPDATED */]: 'updated',\r\n    [\"bum\" /* BEFORE_UNMOUNT */]: 'beforeUnmount hook',\r\n    [\"um\" /* UNMOUNTED */]: 'unmounted hook',\r\n    [\"a\" /* ACTIVATED */]: 'activated hook',\r\n    [\"da\" /* DEACTIVATED */]: 'deactivated hook',\r\n    [\"ec\" /* ERROR_CAPTURED */]: 'errorCaptured hook',\r\n    [\"rtc\" /* RENDER_TRACKED */]: 'renderTracked hook',\r\n    [\"rtg\" /* RENDER_TRIGGERED */]: 'renderTriggered hook',\r\n    [0 /* SETUP_FUNCTION */]: 'setup function',\r\n    [1 /* RENDER_FUNCTION */]: 'render function',\r\n    [2 /* WATCH_GETTER */]: 'watcher getter',\r\n    [3 /* WATCH_CALLBACK */]: 'watcher callback',\r\n    [4 /* WATCH_CLEANUP */]: 'watcher cleanup function',\r\n    [5 /* NATIVE_EVENT_HANDLER */]: 'native event handler',\r\n    [6 /* COMPONENT_EVENT_HANDLER */]: 'component event handler',\r\n    [7 /* VNODE_HOOK */]: 'vnode hook',\r\n    [8 /* DIRECTIVE_HOOK */]: 'directive hook',\r\n    [9 /* TRANSITION_HOOK */]: 'transition hook',\r\n    [10 /* APP_ERROR_HANDLER */]: 'app errorHandler',\r\n    [11 /* APP_WARN_HANDLER */]: 'app warnHandler',\r\n    [12 /* FUNCTION_REF */]: 'ref function',\r\n    [13 /* ASYNC_COMPONENT_LOADER */]: 'async component loader',\r\n    [14 /* SCHEDULER */]: 'scheduler flush. This is likely a Vue internals bug. ' +\r\n        'Please open an issue at https://new-issue.vuejs.org/?repo=vuejs/core'\r\n};\r\nfunction callWithErrorHandling(fn, instance, type, args) {\r\n    let res;\r\n    try {\r\n        res = args ? fn(...args) : fn();\r\n    }\r\n    catch (err) {\r\n        handleError(err, instance, type);\r\n    }\r\n    return res;\r\n}\r\nfunction handleError(err, instance, type, throwInDev = true) {\r\n    const contextVNode = instance ? instance.vnode : null;\r\n    if (instance) {\r\n        let cur = instance.parent;\r\n        // the exposed instance is the render proxy to keep it consistent with 2.x\r\n        const exposedInstance = instance.proxy;\r\n        // in production the hook receives only the error code\r\n        const errorInfo = ErrorTypeStrings[type] ;\r\n        while (cur) {\r\n            const errorCapturedHooks = cur.ec;\r\n            if (errorCapturedHooks) {\r\n                for (let i = 0; i < errorCapturedHooks.length; i++) {\r\n                    if (errorCapturedHooks[i](err, exposedInstance, errorInfo) === false) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            cur = cur.parent;\r\n        }\r\n        // app-level handling\r\n        const appErrorHandler = instance.appContext.config.errorHandler;\r\n        if (appErrorHandler) {\r\n            callWithErrorHandling(appErrorHandler, null, 10 /* APP_ERROR_HANDLER */, [err, exposedInstance, errorInfo]);\r\n            return;\r\n        }\r\n    }\r\n    logError(err, type, contextVNode, throwInDev);\r\n}\r\nfunction logError(err, type, contextVNode, throwInDev = true) {\r\n    {\r\n        const info = ErrorTypeStrings[type];\r\n        if (contextVNode) {\r\n            pushWarningContext(contextVNode);\r\n        }\r\n        warn(`Unhandled error${info ? ` during execution of ${info}` : ``}`);\r\n        if (contextVNode) {\r\n            popWarningContext();\r\n        }\r\n        // crash in dev by default so it's more noticeable\r\n        if (throwInDev) {\r\n            throw err;\r\n        }\r\n        else {\r\n            console.error(err);\r\n        }\r\n    }\r\n}\n\nconst classifyRE = /(?:^|[-_])(\\w)/g;\r\nconst classify = (str) => str.replace(classifyRE, c => c.toUpperCase()).replace(/[-_]/g, '');\r\nfunction getComponentName(Component) {\r\n    return shared.isFunction(Component)\r\n        ? Component.displayName || Component.name\r\n        : Component.name;\r\n}\r\n/* istanbul ignore next */\r\nfunction formatComponentName(instance, Component, isRoot = false) {\r\n    let name = getComponentName(Component);\r\n    if (!name && Component.__file) {\r\n        const match = Component.__file.match(/([^/\\\\]+)\\.\\w+$/);\r\n        if (match) {\r\n            name = match[1];\r\n        }\r\n    }\r\n    if (!name && instance && instance.parent) {\r\n        // try to infer the name based on reverse resolution\r\n        const inferFromRegistry = (registry) => {\r\n            for (const key in registry) {\r\n                if (registry[key] === Component) {\r\n                    return key;\r\n                }\r\n            }\r\n        };\r\n        name =\r\n            inferFromRegistry(instance.components ||\r\n                instance.parent.type.components) || inferFromRegistry(instance.appContext.components);\r\n    }\r\n    return name ? classify(name) : isRoot ? `App` : `Anonymous`;\r\n}\n\nfunction ssrRenderList(source, renderItem) {\r\n    if (shared.isArray(source) || shared.isString(source)) {\r\n        for (let i = 0, l = source.length; i < l; i++) {\r\n            renderItem(source[i], i);\r\n        }\r\n    }\r\n    else if (typeof source === 'number') {\r\n        if (!Number.isInteger(source)) {\r\n            warn(`The v-for range expect an integer value but got ${source}.`);\r\n            return;\r\n        }\r\n        for (let i = 0; i < source; i++) {\r\n            renderItem(i + 1, i);\r\n        }\r\n    }\r\n    else if (shared.isObject(source)) {\r\n        if (source[Symbol.iterator]) {\r\n            const arr = Array.from(source);\r\n            for (let i = 0, l = arr.length; i < l; i++) {\r\n                renderItem(arr[i], i);\r\n            }\r\n        }\r\n        else {\r\n            const keys = Object.keys(source);\r\n            for (let i = 0, l = keys.length; i < l; i++) {\r\n                const key = keys[i];\r\n                renderItem(source[key], key, i);\r\n            }\r\n        }\r\n    }\r\n}\n\nfunction ssrRenderSuspense(push, { default: renderContent }) {\r\n    return __awaiter(this, void 0, void 0, function* () {\r\n        if (renderContent) {\r\n            renderContent();\r\n        }\r\n        else {\r\n            push(`<!---->`);\r\n        }\r\n    });\r\n}\n\nfunction ssrGetDirectiveProps(instance, dir, value, arg, modifiers = {}) {\r\n    if (typeof dir !== 'function' && dir.getSSRProps) {\r\n        return (dir.getSSRProps({\r\n            dir,\r\n            instance,\r\n            value,\r\n            oldValue: undefined,\r\n            arg,\r\n            modifiers\r\n        }, null) || {});\r\n    }\r\n    return {};\r\n}\n\nconst ssrLooseEqual = shared.looseEqual;\r\nfunction ssrLooseContain(arr, value) {\r\n    return shared.looseIndexOf(arr, value) > -1;\r\n}\r\n// for <input :type=\"type\" v-model=\"model\" value=\"value\">\r\nfunction ssrRenderDynamicModel(type, model, value) {\r\n    switch (type) {\r\n        case 'radio':\r\n            return shared.looseEqual(model, value) ? ' checked' : '';\r\n        case 'checkbox':\r\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\r\n                ? ' checked'\r\n                : '';\r\n        default:\r\n            // text types\r\n            return ssrRenderAttr('value', model);\r\n    }\r\n}\r\n// for <input v-bind=\"obj\" v-model=\"model\">\r\nfunction ssrGetDynamicModelProps(existingProps = {}, model) {\r\n    const { type, value } = existingProps;\r\n    switch (type) {\r\n        case 'radio':\r\n            return shared.looseEqual(model, value) ? { checked: true } : null;\r\n        case 'checkbox':\r\n            return (shared.isArray(model) ? ssrLooseContain(model, value) : model)\r\n                ? { checked: true }\r\n                : null;\r\n        default:\r\n            // text types\r\n            return { value: model };\r\n    }\r\n}\n\nvue.initDirectivesForSSR();\n\nexports.ssrIncludeBooleanAttr = shared.includeBooleanAttr;\nexports.pipeToNodeWritable = pipeToNodeWritable;\nexports.pipeToWebWritable = pipeToWebWritable;\nexports.renderToNodeStream = renderToNodeStream;\nexports.renderToSimpleStream = renderToSimpleStream;\nexports.renderToStream = renderToStream;\nexports.renderToString = renderToString;\nexports.renderToWebStream = renderToWebStream;\nexports.ssrGetDirectiveProps = ssrGetDirectiveProps;\nexports.ssrGetDynamicModelProps = ssrGetDynamicModelProps;\nexports.ssrInterpolate = ssrInterpolate;\nexports.ssrLooseContain = ssrLooseContain;\nexports.ssrLooseEqual = ssrLooseEqual;\nexports.ssrRenderAttr = ssrRenderAttr;\nexports.ssrRenderAttrs = ssrRenderAttrs;\nexports.ssrRenderClass = ssrRenderClass;\nexports.ssrRenderComponent = ssrRenderComponent;\nexports.ssrRenderDynamicAttr = ssrRenderDynamicAttr;\nexports.ssrRenderDynamicModel = ssrRenderDynamicModel;\nexports.ssrRenderList = ssrRenderList;\nexports.ssrRenderSlot = ssrRenderSlot;\nexports.ssrRenderStyle = ssrRenderStyle;\nexports.ssrRenderSuspense = ssrRenderSuspense;\nexports.ssrRenderTeleport = ssrRenderTeleport;\nexports.ssrRenderVNode = renderVNode;\n"]}