{"version":3,"sources":["reactivity-transform.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar MagicString = require('magic-string');\nvar estreeWalker = require('estree-walker');\nvar compilerCore = require('@vue/compiler-core');\nvar parser = require('@babel/parser');\nvar shared = require('@vue/shared');\n\nfunction _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e['default'] : e; }\n\nvar MagicString__default = /*#__PURE__*/_interopDefaultLegacy(MagicString);\n\nconst CONVERT_SYMBOL = '$';\r\nconst ESCAPE_SYMBOL = '$$';\r\nconst shorthands = ['ref', 'computed', 'shallowRef', 'toRef', 'customRef'];\r\nconst transformCheckRE = /[^\\w]\\$(?:\\$|ref|computed|shallowRef)?\\s*(\\(|\\<)/;\r\nfunction shouldTransform(src) {\r\n    return transformCheckRE.test(src);\r\n}\r\nfunction transform(src, { filename, sourceMap, parserPlugins, importHelpersFrom = 'vue' } = {}) {\r\n    const plugins = parserPlugins || [];\r\n    if (filename) {\r\n        if (/\\.tsx?$/.test(filename)) {\r\n            plugins.push('typescript');\r\n        }\r\n        if (filename.endsWith('x')) {\r\n            plugins.push('jsx');\r\n        }\r\n    }\r\n    const ast = parser.parse(src, {\r\n        sourceType: 'module',\r\n        plugins\r\n    });\r\n    const s = new MagicString__default(src);\r\n    const res = transformAST(ast.program, s, 0);\r\n    // inject helper imports\r\n    if (res.importedHelpers.length) {\r\n        s.prepend(`import { ${res.importedHelpers\r\n            .map(h => `${h} as _${h}`)\r\n            .join(', ')} } from '${importHelpersFrom}'\\n`);\r\n    }\r\n    return Object.assign(Object.assign({}, res), { code: s.toString(), map: sourceMap\r\n            ? s.generateMap({\r\n                source: filename,\r\n                hires: true,\r\n                includeContent: true\r\n            })\r\n            : null });\r\n}\r\nfunction transformAST(ast, s, offset = 0, knownRefs, knownProps) {\r\n    // TODO remove when out of experimental\r\n    warnExperimental();\r\n    let convertSymbol = CONVERT_SYMBOL;\r\n    let escapeSymbol = ESCAPE_SYMBOL;\r\n    // macro import handling\r\n    for (const node of ast.body) {\r\n        if (node.type === 'ImportDeclaration' &&\r\n            node.source.value === 'vue/macros') {\r\n            // remove macro imports\r\n            s.remove(node.start + offset, node.end + offset);\r\n            // check aliasing\r\n            for (const specifier of node.specifiers) {\r\n                if (specifier.type === 'ImportSpecifier') {\r\n                    const imported = specifier.imported.name;\r\n                    const local = specifier.local.name;\r\n                    if (local !== imported) {\r\n                        if (imported === ESCAPE_SYMBOL) {\r\n                            escapeSymbol = local;\r\n                        }\r\n                        else if (imported === CONVERT_SYMBOL) {\r\n                            convertSymbol = local;\r\n                        }\r\n                        else {\r\n                            error(`macro imports for ref-creating methods do not support aliasing.`, specifier);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    const importedHelpers = new Set();\r\n    const rootScope = {};\r\n    const scopeStack = [rootScope];\r\n    let currentScope = rootScope;\r\n    let escapeScope; // inside $$()\r\n    const excludedIds = new WeakSet();\r\n    const parentStack = [];\r\n    const propsLocalToPublicMap = Object.create(null);\r\n    if (knownRefs) {\r\n        for (const key of knownRefs) {\r\n            rootScope[key] = true;\r\n        }\r\n    }\r\n    if (knownProps) {\r\n        for (const key in knownProps) {\r\n            const { local } = knownProps[key];\r\n            rootScope[local] = 'prop';\r\n            propsLocalToPublicMap[local] = key;\r\n        }\r\n    }\r\n    function isRefCreationCall(callee) {\r\n        if (callee === convertSymbol) {\r\n            return convertSymbol;\r\n        }\r\n        if (callee[0] === '$' && shorthands.includes(callee.slice(1))) {\r\n            return callee;\r\n        }\r\n        return false;\r\n    }\r\n    function error(msg, node) {\r\n        const e = new Error(msg);\r\n        e.node = node;\r\n        throw e;\r\n    }\r\n    function helper(msg) {\r\n        importedHelpers.add(msg);\r\n        return `_${msg}`;\r\n    }\r\n    function registerBinding(id, isRef = false) {\r\n        excludedIds.add(id);\r\n        if (currentScope) {\r\n            currentScope[id.name] = isRef;\r\n        }\r\n        else {\r\n            error('registerBinding called without active scope, something is wrong.', id);\r\n        }\r\n    }\r\n    const registerRefBinding = (id) => registerBinding(id, true);\r\n    let tempVarCount = 0;\r\n    function genTempVar() {\r\n        return `__$temp_${++tempVarCount}`;\r\n    }\r\n    function snip(node) {\r\n        return s.original.slice(node.start + offset, node.end + offset);\r\n    }\r\n    function walkScope(node, isRoot = false) {\r\n        for (const stmt of node.body) {\r\n            if (stmt.type === 'VariableDeclaration') {\r\n                walkVariableDeclaration(stmt, isRoot);\r\n            }\r\n            else if (stmt.type === 'FunctionDeclaration' ||\r\n                stmt.type === 'ClassDeclaration') {\r\n                if (stmt.declare || !stmt.id)\r\n                    continue;\r\n                registerBinding(stmt.id);\r\n            }\r\n            else if ((stmt.type === 'ForOfStatement' || stmt.type === 'ForInStatement') &&\r\n                stmt.left.type === 'VariableDeclaration') {\r\n                walkVariableDeclaration(stmt.left);\r\n            }\r\n            else if (stmt.type === 'ExportNamedDeclaration' &&\r\n                stmt.declaration &&\r\n                stmt.declaration.type === 'VariableDeclaration') {\r\n                walkVariableDeclaration(stmt.declaration, isRoot);\r\n            }\r\n            else if (stmt.type === 'LabeledStatement' &&\r\n                stmt.body.type === 'VariableDeclaration') {\r\n                walkVariableDeclaration(stmt.body, isRoot);\r\n            }\r\n        }\r\n    }\r\n    function walkVariableDeclaration(stmt, isRoot = false) {\r\n        if (stmt.declare) {\r\n            return;\r\n        }\r\n        for (const decl of stmt.declarations) {\r\n            let refCall;\r\n            const isCall = decl.init &&\r\n                decl.init.type === 'CallExpression' &&\r\n                decl.init.callee.type === 'Identifier';\r\n            if (isCall &&\r\n                (refCall = isRefCreationCall(decl.init.callee.name))) {\r\n                processRefDeclaration(refCall, decl.id, decl.init);\r\n            }\r\n            else {\r\n                const isProps = isRoot && isCall && decl.init.callee.name === 'defineProps';\r\n                for (const id of compilerCore.extractIdentifiers(decl.id)) {\r\n                    if (isProps) {\r\n                        // for defineProps destructure, only exclude them since they\r\n                        // are already passed in as knownProps\r\n                        excludedIds.add(id);\r\n                    }\r\n                    else {\r\n                        registerBinding(id);\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n    function processRefDeclaration(method, id, call) {\r\n        excludedIds.add(call.callee);\r\n        if (method === convertSymbol) {\r\n            // $\r\n            // remove macro\r\n            s.remove(call.callee.start + offset, call.callee.end + offset);\r\n            if (id.type === 'Identifier') {\r\n                // single variable\r\n                registerRefBinding(id);\r\n            }\r\n            else if (id.type === 'ObjectPattern') {\r\n                processRefObjectPattern(id, call);\r\n            }\r\n            else if (id.type === 'ArrayPattern') {\r\n                processRefArrayPattern(id, call);\r\n            }\r\n        }\r\n        else {\r\n            // shorthands\r\n            if (id.type === 'Identifier') {\r\n                registerRefBinding(id);\r\n                // replace call\r\n                s.overwrite(call.start + offset, call.start + method.length + offset, helper(method.slice(1)));\r\n            }\r\n            else {\r\n                error(`${method}() cannot be used with destructure patterns.`, call);\r\n            }\r\n        }\r\n    }\r\n    function processRefObjectPattern(pattern, call, tempVar, path = []) {\r\n        if (!tempVar) {\r\n            tempVar = genTempVar();\r\n            // const { x } = $(useFoo()) --> const __$temp_1 = useFoo()\r\n            s.overwrite(pattern.start + offset, pattern.end + offset, tempVar);\r\n        }\r\n        for (const p of pattern.properties) {\r\n            let nameId;\r\n            let key;\r\n            let defaultValue;\r\n            if (p.type === 'ObjectProperty') {\r\n                if (p.key.start === p.value.start) {\r\n                    // shorthand { foo }\r\n                    nameId = p.key;\r\n                    if (p.value.type === 'Identifier') {\r\n                        // avoid shorthand value identifier from being processed\r\n                        excludedIds.add(p.value);\r\n                    }\r\n                    else if (p.value.type === 'AssignmentPattern' &&\r\n                        p.value.left.type === 'Identifier') {\r\n                        // { foo = 1 }\r\n                        excludedIds.add(p.value.left);\r\n                        defaultValue = p.value.right;\r\n                    }\r\n                }\r\n                else {\r\n                    key = p.computed ? p.key : p.key.name;\r\n                    if (p.value.type === 'Identifier') {\r\n                        // { foo: bar }\r\n                        nameId = p.value;\r\n                    }\r\n                    else if (p.value.type === 'ObjectPattern') {\r\n                        processRefObjectPattern(p.value, call, tempVar, [...path, key]);\r\n                    }\r\n                    else if (p.value.type === 'ArrayPattern') {\r\n                        processRefArrayPattern(p.value, call, tempVar, [...path, key]);\r\n                    }\r\n                    else if (p.value.type === 'AssignmentPattern') {\r\n                        if (p.value.left.type === 'Identifier') {\r\n                            // { foo: bar = 1 }\r\n                            nameId = p.value.left;\r\n                            defaultValue = p.value.right;\r\n                        }\r\n                        else if (p.value.left.type === 'ObjectPattern') {\r\n                            processRefObjectPattern(p.value.left, call, tempVar, [\r\n                                ...path,\r\n                                [key, p.value.right]\r\n                            ]);\r\n                        }\r\n                        else if (p.value.left.type === 'ArrayPattern') {\r\n                            processRefArrayPattern(p.value.left, call, tempVar, [\r\n                                ...path,\r\n                                [key, p.value.right]\r\n                            ]);\r\n                        }\r\n                        else ;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // rest element { ...foo }\r\n                error(`reactivity destructure does not support rest elements.`, p);\r\n            }\r\n            if (nameId) {\r\n                registerRefBinding(nameId);\r\n                // inject toRef() after original replaced pattern\r\n                const source = pathToString(tempVar, path);\r\n                const keyStr = shared.isString(key)\r\n                    ? `'${key}'`\r\n                    : key\r\n                        ? snip(key)\r\n                        : `'${nameId.name}'`;\r\n                const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``;\r\n                s.appendLeft(call.end + offset, `,\\n  ${nameId.name} = ${helper('toRef')}(${source}, ${keyStr}${defaultStr})`);\r\n            }\r\n        }\r\n    }\r\n    function processRefArrayPattern(pattern, call, tempVar, path = []) {\r\n        if (!tempVar) {\r\n            // const [x] = $(useFoo()) --> const __$temp_1 = useFoo()\r\n            tempVar = genTempVar();\r\n            s.overwrite(pattern.start + offset, pattern.end + offset, tempVar);\r\n        }\r\n        for (let i = 0; i < pattern.elements.length; i++) {\r\n            const e = pattern.elements[i];\r\n            if (!e)\r\n                continue;\r\n            let nameId;\r\n            let defaultValue;\r\n            if (e.type === 'Identifier') {\r\n                // [a] --> [__a]\r\n                nameId = e;\r\n            }\r\n            else if (e.type === 'AssignmentPattern') {\r\n                // [a = 1]\r\n                nameId = e.left;\r\n                defaultValue = e.right;\r\n            }\r\n            else if (e.type === 'RestElement') {\r\n                // [...a]\r\n                error(`reactivity destructure does not support rest elements.`, e);\r\n            }\r\n            else if (e.type === 'ObjectPattern') {\r\n                processRefObjectPattern(e, call, tempVar, [...path, i]);\r\n            }\r\n            else if (e.type === 'ArrayPattern') {\r\n                processRefArrayPattern(e, call, tempVar, [...path, i]);\r\n            }\r\n            if (nameId) {\r\n                registerRefBinding(nameId);\r\n                // inject toRef() after original replaced pattern\r\n                const source = pathToString(tempVar, path);\r\n                const defaultStr = defaultValue ? `, ${snip(defaultValue)}` : ``;\r\n                s.appendLeft(call.end + offset, `,\\n  ${nameId.name} = ${helper('toRef')}(${source}, ${i}${defaultStr})`);\r\n            }\r\n        }\r\n    }\r\n    function pathToString(source, path) {\r\n        if (path.length) {\r\n            for (const seg of path) {\r\n                if (shared.isArray(seg)) {\r\n                    source = `(${source}${segToString(seg[0])} || ${snip(seg[1])})`;\r\n                }\r\n                else {\r\n                    source += segToString(seg);\r\n                }\r\n            }\r\n        }\r\n        return source;\r\n    }\r\n    function segToString(seg) {\r\n        if (typeof seg === 'number') {\r\n            return `[${seg}]`;\r\n        }\r\n        else if (typeof seg === 'string') {\r\n            return `.${seg}`;\r\n        }\r\n        else {\r\n            return snip(seg);\r\n        }\r\n    }\r\n    function rewriteId(scope, id, parent, parentStack) {\r\n        if (shared.hasOwn(scope, id.name)) {\r\n            const bindingType = scope[id.name];\r\n            if (bindingType) {\r\n                const isProp = bindingType === 'prop';\r\n                if (compilerCore.isStaticProperty(parent) && parent.shorthand) {\r\n                    // let binding used in a property shorthand\r\n                    // skip for destructure patterns\r\n                    if (!parent.inPattern ||\r\n                        compilerCore.isInDestructureAssignment(parent, parentStack)) {\r\n                        if (isProp) {\r\n                            if (escapeScope) {\r\n                                // prop binding in $$()\r\n                                // { prop } -> { prop: __prop_prop }\r\n                                registerEscapedPropBinding(id);\r\n                                s.appendLeft(id.end + offset, `: __props_${propsLocalToPublicMap[id.name]}`);\r\n                            }\r\n                            else {\r\n                                // { prop } -> { prop: __prop.prop }\r\n                                s.appendLeft(id.end + offset, `: __props.${propsLocalToPublicMap[id.name]}`);\r\n                            }\r\n                        }\r\n                        else {\r\n                            // { foo } -> { foo: foo.value }\r\n                            s.appendLeft(id.end + offset, `: ${id.name}.value`);\r\n                        }\r\n                    }\r\n                }\r\n                else {\r\n                    if (isProp) {\r\n                        if (escapeScope) {\r\n                            // x --> __props_x\r\n                            registerEscapedPropBinding(id);\r\n                            s.overwrite(id.start + offset, id.end + offset, `__props_${propsLocalToPublicMap[id.name]}`);\r\n                        }\r\n                        else {\r\n                            // x --> __props.x\r\n                            s.overwrite(id.start + offset, id.end + offset, `__props.${propsLocalToPublicMap[id.name]}`);\r\n                        }\r\n                    }\r\n                    else {\r\n                        // x --> x.value\r\n                        s.appendLeft(id.end + offset, '.value');\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n    const propBindingRefs = {};\r\n    function registerEscapedPropBinding(id) {\r\n        if (!propBindingRefs.hasOwnProperty(id.name)) {\r\n            propBindingRefs[id.name] = true;\r\n            const publicKey = propsLocalToPublicMap[id.name];\r\n            s.prependRight(offset, `const __props_${publicKey} = ${helper(`toRef`)}(__props, '${publicKey}')\\n`);\r\n        }\r\n    }\r\n    // check root scope first\r\n    walkScope(ast, true);\r\n    estreeWalker.walk(ast, {\r\n        enter(node, parent) {\r\n            parent && parentStack.push(parent);\r\n            // function scopes\r\n            if (compilerCore.isFunctionType(node)) {\r\n                scopeStack.push((currentScope = {}));\r\n                compilerCore.walkFunctionParams(node, registerBinding);\r\n                if (node.body.type === 'BlockStatement') {\r\n                    walkScope(node.body);\r\n                }\r\n                return;\r\n            }\r\n            // non-function block scopes\r\n            if (node.type === 'BlockStatement' && !compilerCore.isFunctionType(parent)) {\r\n                scopeStack.push((currentScope = {}));\r\n                walkScope(node);\r\n                return;\r\n            }\r\n            // skip type nodes\r\n            if (parent &&\r\n                parent.type.startsWith('TS') &&\r\n                parent.type !== 'TSAsExpression' &&\r\n                parent.type !== 'TSNonNullExpression' &&\r\n                parent.type !== 'TSTypeAssertion') {\r\n                return this.skip();\r\n            }\r\n            if (node.type === 'Identifier' &&\r\n                // if inside $$(), skip unless this is a destructured prop binding\r\n                !(escapeScope && rootScope[node.name] !== 'prop') &&\r\n                compilerCore.isReferencedIdentifier(node, parent, parentStack) &&\r\n                !excludedIds.has(node)) {\r\n                // walk up the scope chain to check if id should be appended .value\r\n                let i = scopeStack.length;\r\n                while (i--) {\r\n                    if (rewriteId(scopeStack[i], node, parent, parentStack)) {\r\n                        return;\r\n                    }\r\n                }\r\n            }\r\n            if (node.type === 'CallExpression' && node.callee.type === 'Identifier') {\r\n                const callee = node.callee.name;\r\n                const refCall = isRefCreationCall(callee);\r\n                if (refCall && (!parent || parent.type !== 'VariableDeclarator')) {\r\n                    return error(`${refCall} can only be used as the initializer of ` +\r\n                        `a variable declaration.`, node);\r\n                }\r\n                if (callee === escapeSymbol) {\r\n                    s.remove(node.callee.start + offset, node.callee.end + offset);\r\n                    escapeScope = node;\r\n                }\r\n                // TODO remove when out of experimental\r\n                if (callee === '$raw') {\r\n                    error(`$raw() has been replaced by $$(). ` +\r\n                        `See ${RFC_LINK} for latest updates.`, node);\r\n                }\r\n                if (callee === '$fromRef') {\r\n                    error(`$fromRef() has been replaced by $(). ` +\r\n                        `See ${RFC_LINK} for latest updates.`, node);\r\n                }\r\n            }\r\n        },\r\n        leave(node, parent) {\r\n            parent && parentStack.pop();\r\n            if ((node.type === 'BlockStatement' && !compilerCore.isFunctionType(parent)) ||\r\n                compilerCore.isFunctionType(node)) {\r\n                scopeStack.pop();\r\n                currentScope = scopeStack[scopeStack.length - 1] || null;\r\n            }\r\n            if (node === escapeScope) {\r\n                escapeScope = undefined;\r\n            }\r\n        }\r\n    });\r\n    return {\r\n        rootRefs: Object.keys(rootScope).filter(key => rootScope[key] === true),\r\n        importedHelpers: [...importedHelpers]\r\n    };\r\n}\r\nconst RFC_LINK = `https://github.com/vuejs/rfcs/discussions/369`;\r\nconst hasWarned = {};\r\nfunction warnExperimental() {\r\n    // eslint-disable-next-line\r\n    if (typeof window !== 'undefined') {\r\n        return;\r\n    }\r\n    warnOnce(`Reactivity transform is an experimental feature.\\n` +\r\n        `Experimental features may change behavior between patch versions.\\n` +\r\n        `It is recommended to pin your vue dependencies to exact versions to avoid breakage.\\n` +\r\n        `You can follow the proposal's status at ${RFC_LINK}.`);\r\n}\r\nfunction warnOnce(msg) {\r\n    const isNodeProd = typeof process !== 'undefined' && process.env.NODE_ENV === 'production';\r\n    if (!isNodeProd && !false && !hasWarned[msg]) {\r\n        hasWarned[msg] = true;\r\n        warn(msg);\r\n    }\r\n}\r\nfunction warn(msg) {\r\n    console.warn(`\\x1b[1m\\x1b[33m[@vue/reactivity-transform]\\x1b[0m\\x1b[33m ${msg}\\x1b[0m\\n`);\r\n}\n\nexports.shouldTransform = shouldTransform;\nexports.transform = transform;\nexports.transformAST = transformAST;\n"]}