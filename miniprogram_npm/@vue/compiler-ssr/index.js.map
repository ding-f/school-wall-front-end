{"version":3,"sources":["compiler-ssr.cjs.js"],"names":[],"mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"index.js","sourcesContent":["\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nvar compilerDom = require('@vue/compiler-dom');\nvar shared = require('@vue/shared');\n\nconst SSR_INTERPOLATE = Symbol(`ssrInterpolate`);\r\nconst SSR_RENDER_VNODE = Symbol(`ssrRenderVNode`);\r\nconst SSR_RENDER_COMPONENT = Symbol(`ssrRenderComponent`);\r\nconst SSR_RENDER_SLOT = Symbol(`ssrRenderSlot`);\r\nconst SSR_RENDER_CLASS = Symbol(`ssrRenderClass`);\r\nconst SSR_RENDER_STYLE = Symbol(`ssrRenderStyle`);\r\nconst SSR_RENDER_ATTRS = Symbol(`ssrRenderAttrs`);\r\nconst SSR_RENDER_ATTR = Symbol(`ssrRenderAttr`);\r\nconst SSR_RENDER_DYNAMIC_ATTR = Symbol(`ssrRenderDynamicAttr`);\r\nconst SSR_RENDER_LIST = Symbol(`ssrRenderList`);\r\nconst SSR_INCLUDE_BOOLEAN_ATTR = Symbol(`ssrIncludeBooleanAttr`);\r\nconst SSR_LOOSE_EQUAL = Symbol(`ssrLooseEqual`);\r\nconst SSR_LOOSE_CONTAIN = Symbol(`ssrLooseContain`);\r\nconst SSR_RENDER_DYNAMIC_MODEL = Symbol(`ssrRenderDynamicModel`);\r\nconst SSR_GET_DYNAMIC_MODEL_PROPS = Symbol(`ssrGetDynamicModelProps`);\r\nconst SSR_RENDER_TELEPORT = Symbol(`ssrRenderTeleport`);\r\nconst SSR_RENDER_SUSPENSE = Symbol(`ssrRenderSuspense`);\r\nconst SSR_GET_DIRECTIVE_PROPS = Symbol(`ssrGetDirectiveProps`);\r\nconst ssrHelpers = {\r\n    [SSR_INTERPOLATE]: `ssrInterpolate`,\r\n    [SSR_RENDER_VNODE]: `ssrRenderVNode`,\r\n    [SSR_RENDER_COMPONENT]: `ssrRenderComponent`,\r\n    [SSR_RENDER_SLOT]: `ssrRenderSlot`,\r\n    [SSR_RENDER_CLASS]: `ssrRenderClass`,\r\n    [SSR_RENDER_STYLE]: `ssrRenderStyle`,\r\n    [SSR_RENDER_ATTRS]: `ssrRenderAttrs`,\r\n    [SSR_RENDER_ATTR]: `ssrRenderAttr`,\r\n    [SSR_RENDER_DYNAMIC_ATTR]: `ssrRenderDynamicAttr`,\r\n    [SSR_RENDER_LIST]: `ssrRenderList`,\r\n    [SSR_INCLUDE_BOOLEAN_ATTR]: `ssrIncludeBooleanAttr`,\r\n    [SSR_LOOSE_EQUAL]: `ssrLooseEqual`,\r\n    [SSR_LOOSE_CONTAIN]: `ssrLooseContain`,\r\n    [SSR_RENDER_DYNAMIC_MODEL]: `ssrRenderDynamicModel`,\r\n    [SSR_GET_DYNAMIC_MODEL_PROPS]: `ssrGetDynamicModelProps`,\r\n    [SSR_RENDER_TELEPORT]: `ssrRenderTeleport`,\r\n    [SSR_RENDER_SUSPENSE]: `ssrRenderSuspense`,\r\n    [SSR_GET_DIRECTIVE_PROPS]: `ssrGetDirectiveProps`\r\n};\r\n// Note: these are helpers imported from @vue/server-renderer\r\n// make sure the names match!\r\ncompilerDom.registerRuntimeHelpers(ssrHelpers);\n\n// Plugin for the first transform pass, which simply constructs the AST node\r\nconst ssrTransformIf = compilerDom.createStructuralDirectiveTransform(/^(if|else|else-if)$/, compilerDom.processIf);\r\n// This is called during the 2nd transform pass to construct the SSR-specific\r\n// codegen nodes.\r\nfunction ssrProcessIf(node, context, disableNestedFragments = false) {\r\n    const [rootBranch] = node.branches;\r\n    const ifStatement = compilerDom.createIfStatement(rootBranch.condition, processIfBranch(rootBranch, context, disableNestedFragments));\r\n    context.pushStatement(ifStatement);\r\n    let currentIf = ifStatement;\r\n    for (let i = 1; i < node.branches.length; i++) {\r\n        const branch = node.branches[i];\r\n        const branchBlockStatement = processIfBranch(branch, context, disableNestedFragments);\r\n        if (branch.condition) {\r\n            // else-if\r\n            currentIf = currentIf.alternate = compilerDom.createIfStatement(branch.condition, branchBlockStatement);\r\n        }\r\n        else {\r\n            // else\r\n            currentIf.alternate = branchBlockStatement;\r\n        }\r\n    }\r\n    if (!currentIf.alternate) {\r\n        currentIf.alternate = compilerDom.createBlockStatement([\r\n            compilerDom.createCallExpression(`_push`, ['`<!---->`'])\r\n        ]);\r\n    }\r\n}\r\nfunction processIfBranch(branch, context, disableNestedFragments = false) {\r\n    const { children } = branch;\r\n    const needFragmentWrapper = !disableNestedFragments &&\r\n        (children.length !== 1 || children[0].type !== 1 /* ELEMENT */) &&\r\n        // optimize away nested fragments when the only child is a ForNode\r\n        !(children.length === 1 && children[0].type === 11 /* FOR */);\r\n    return processChildrenAsStatement(children, context, needFragmentWrapper);\r\n}\n\n// Plugin for the first transform pass, which simply constructs the AST node\r\nconst ssrTransformFor = compilerDom.createStructuralDirectiveTransform('for', compilerDom.processFor);\r\n// This is called during the 2nd transform pass to construct the SSR-specific\r\n// codegen nodes.\r\nfunction ssrProcessFor(node, context, disableNestedFragments = false) {\r\n    const needFragmentWrapper = !disableNestedFragments &&\r\n        (node.children.length !== 1 || node.children[0].type !== 1 /* ELEMENT */);\r\n    const renderLoop = compilerDom.createFunctionExpression(compilerDom.createForLoopParams(node.parseResult));\r\n    renderLoop.body = processChildrenAsStatement(node.children, context, needFragmentWrapper);\r\n    // v-for always renders a fragment unless explicitly disabled\r\n    if (!disableNestedFragments) {\r\n        context.pushStringPart(`<!--[-->`);\r\n    }\r\n    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_LIST), [\r\n        node.source,\r\n        renderLoop\r\n    ]));\r\n    if (!disableNestedFragments) {\r\n        context.pushStringPart(`<!--]-->`);\r\n    }\r\n}\n\nconst ssrTransformSlotOutlet = (node, context) => {\r\n    if (compilerDom.isSlotOutlet(node)) {\r\n        const { slotName, slotProps } = compilerDom.processSlotOutlet(node, context);\r\n        const args = [\r\n            `_ctx.$slots`,\r\n            slotName,\r\n            slotProps || `{}`,\r\n            // fallback content placeholder. will be replaced in the process phase\r\n            `null`,\r\n            `_push`,\r\n            `_parent`\r\n        ];\r\n        // inject slot scope id if current template uses :slotted\r\n        if (context.scopeId && context.slotted !== false) {\r\n            args.push(`\"${context.scopeId}-s\"`);\r\n        }\r\n        node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_SLOT), args);\r\n    }\r\n};\r\nfunction ssrProcessSlotOutlet(node, context) {\r\n    const renderCall = node.ssrCodegenNode;\r\n    // has fallback content\r\n    if (node.children.length) {\r\n        const fallbackRenderFn = compilerDom.createFunctionExpression([]);\r\n        fallbackRenderFn.body = processChildrenAsStatement(node.children, context);\r\n        // _renderSlot(slots, name, props, fallback, ...)\r\n        renderCall.arguments[3] = fallbackRenderFn;\r\n    }\r\n    // Forwarded <slot/>. Merge slot scope ids\r\n    if (context.withSlotScopeId) {\r\n        const slotScopeId = renderCall.arguments[6];\r\n        renderCall.arguments[6] = slotScopeId\r\n            ? `${slotScopeId} + _scopeId`\r\n            : `_scopeId`;\r\n    }\r\n    context.pushStatement(node.ssrCodegenNode);\r\n}\n\nfunction createSSRCompilerError(code, loc) {\r\n    return compilerDom.createCompilerError(code, loc, SSRErrorMessages);\r\n}\r\nconst SSRErrorMessages = {\r\n    [61 /* X_SSR_UNSAFE_ATTR_NAME */]: `Unsafe attribute name for SSR.`,\r\n    [62 /* X_SSR_NO_TELEPORT_TARGET */]: `Missing the 'to' prop on teleport element.`,\r\n    [63 /* X_SSR_INVALID_AST_NODE */]: `Invalid AST node during SSR transform.`\r\n};\n\n// Note: this is a 2nd-pass codegen transform.\r\nfunction ssrProcessTeleport(node, context) {\r\n    const targetProp = compilerDom.findProp(node, 'to');\r\n    if (!targetProp) {\r\n        context.onError(createSSRCompilerError(62 /* X_SSR_NO_TELEPORT_TARGET */, node.loc));\r\n        return;\r\n    }\r\n    let target;\r\n    if (targetProp.type === 6 /* ATTRIBUTE */) {\r\n        target =\r\n            targetProp.value && compilerDom.createSimpleExpression(targetProp.value.content, true);\r\n    }\r\n    else {\r\n        target = targetProp.exp;\r\n    }\r\n    if (!target) {\r\n        context.onError(createSSRCompilerError(62 /* X_SSR_NO_TELEPORT_TARGET */, targetProp.loc));\r\n        return;\r\n    }\r\n    const disabledProp = compilerDom.findProp(node, 'disabled', false, true /* allow empty */);\r\n    const disabled = disabledProp\r\n        ? disabledProp.type === 6 /* ATTRIBUTE */\r\n            ? `true`\r\n            : disabledProp.exp || `false`\r\n        : `false`;\r\n    const contentRenderFn = compilerDom.createFunctionExpression([`_push`], undefined, // Body is added later\r\n    true, // newline\r\n    false, // isSlot\r\n    node.loc);\r\n    contentRenderFn.body = processChildrenAsStatement(node.children, context);\r\n    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_TELEPORT), [\r\n        `_push`,\r\n        contentRenderFn,\r\n        target,\r\n        disabled,\r\n        `_parent`\r\n    ]));\r\n}\n\nconst wipMap = new WeakMap();\r\n// phase 1\r\nfunction ssrTransformSuspense(node, context) {\r\n    return () => {\r\n        if (node.children.length) {\r\n            const wipEntry = {\r\n                slotsExp: null,\r\n                wipSlots: []\r\n            };\r\n            wipMap.set(node, wipEntry);\r\n            wipEntry.slotsExp = compilerDom.buildSlots(node, context, (_props, children, loc) => {\r\n                const fn = compilerDom.createFunctionExpression([], undefined, // no return, assign body later\r\n                true, // newline\r\n                false, // suspense slots are not treated as normal slots\r\n                loc);\r\n                wipEntry.wipSlots.push({\r\n                    fn,\r\n                    children\r\n                });\r\n                return fn;\r\n            }).slots;\r\n        }\r\n    };\r\n}\r\n// phase 2\r\nfunction ssrProcessSuspense(node, context) {\r\n    // complete wip slots with ssr code\r\n    const wipEntry = wipMap.get(node);\r\n    if (!wipEntry) {\r\n        return;\r\n    }\r\n    const { slotsExp, wipSlots } = wipEntry;\r\n    for (let i = 0; i < wipSlots.length; i++) {\r\n        const { fn, children } = wipSlots[i];\r\n        fn.body = processChildrenAsStatement(children, context);\r\n    }\r\n    // _push(ssrRenderSuspense(slots))\r\n    context.pushStatement(compilerDom.createCallExpression(context.helper(SSR_RENDER_SUSPENSE), [\r\n        `_push`,\r\n        slotsExp\r\n    ]));\r\n}\n\nfunction ssrProcessTransitionGroup(node, context) {\r\n    const tag = compilerDom.findProp(node, 'tag');\r\n    if (tag) {\r\n        if (tag.type === 7 /* DIRECTIVE */) {\r\n            // dynamic :tag\r\n            context.pushStringPart(`<`);\r\n            context.pushStringPart(tag.exp);\r\n            context.pushStringPart(`>`);\r\n            processChildren(node.children, context, false, \r\n            /**\r\n             * TransitionGroup has the special runtime behavior of flattening and\r\n             * concatenating all children into a single fragment (in order for them to\r\n             * be patched using the same key map) so we need to account for that here\r\n             * by disabling nested fragment wrappers from being generated.\r\n             */\r\n            true);\r\n            context.pushStringPart(`</`);\r\n            context.pushStringPart(tag.exp);\r\n            context.pushStringPart(`>`);\r\n        }\r\n        else {\r\n            // static tag\r\n            context.pushStringPart(`<${tag.value.content}>`);\r\n            processChildren(node.children, context, false, true);\r\n            context.pushStringPart(`</${tag.value.content}>`);\r\n        }\r\n    }\r\n    else {\r\n        // fragment\r\n        processChildren(node.children, context, true, true);\r\n    }\r\n}\n\n// for directives with children overwrite (e.g. v-html & v-text), we need to\r\n// store the raw children so that they can be added in the 2nd pass.\r\nconst rawChildrenMap = new WeakMap();\r\nconst ssrTransformElement = (node, context) => {\r\n    if (node.type !== 1 /* ELEMENT */ ||\r\n        node.tagType !== 0 /* ELEMENT */) {\r\n        return;\r\n    }\r\n    return function ssrPostTransformElement() {\r\n        // element\r\n        // generate the template literal representing the open tag.\r\n        const openTag = [`<${node.tag}`];\r\n        // some tags need to be passed to runtime for special checks\r\n        const needTagForRuntime = node.tag === 'textarea' || node.tag.indexOf('-') > 0;\r\n        // v-bind=\"obj\", v-bind:[key] and custom directives can potentially\r\n        // overwrite other static attrs and can affect final rendering result,\r\n        // so when they are present we need to bail out to full `renderAttrs`\r\n        const hasDynamicVBind = compilerDom.hasDynamicKeyVBind(node);\r\n        const hasCustomDir = node.props.some(p => p.type === 7 /* DIRECTIVE */ && !shared.isBuiltInDirective(p.name));\r\n        const needMergeProps = hasDynamicVBind || hasCustomDir;\r\n        if (needMergeProps) {\r\n            const { props, directives } = compilerDom.buildProps(node, context, node.props, true /* ssr */);\r\n            if (props || directives.length) {\r\n                const mergedProps = buildSSRProps(props, directives, context);\r\n                const propsExp = compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTRS), [mergedProps]);\r\n                if (node.tag === 'textarea') {\r\n                    const existingText = node.children[0];\r\n                    // If interpolation, this is dynamic <textarea> content, potentially\r\n                    // injected by v-model and takes higher priority than v-bind value\r\n                    if (!existingText || existingText.type !== 5 /* INTERPOLATION */) {\r\n                        // <textarea> with dynamic v-bind. We don't know if the final props\r\n                        // will contain .value, so we will have to do something special:\r\n                        // assign the merged props to a temp variable, and check whether\r\n                        // it contains value (if yes, render is as children).\r\n                        const tempId = `_temp${context.temps++}`;\r\n                        propsExp.arguments = [\r\n                            compilerDom.createAssignmentExpression(compilerDom.createSimpleExpression(tempId, false), mergedProps)\r\n                        ];\r\n                        rawChildrenMap.set(node, compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [\r\n                            compilerDom.createConditionalExpression(compilerDom.createSimpleExpression(`\"value\" in ${tempId}`, false), compilerDom.createSimpleExpression(`${tempId}.value`, false), compilerDom.createSimpleExpression(existingText ? existingText.content : ``, true), false)\r\n                        ]));\r\n                    }\r\n                }\r\n                else if (node.tag === 'input') {\r\n                    // <input v-bind=\"obj\" v-model>\r\n                    // we need to determine the props to render for the dynamic v-model\r\n                    // and merge it with the v-bind expression.\r\n                    const vModel = findVModel(node);\r\n                    if (vModel) {\r\n                        // 1. save the props (san v-model) in a temp variable\r\n                        const tempId = `_temp${context.temps++}`;\r\n                        const tempExp = compilerDom.createSimpleExpression(tempId, false);\r\n                        propsExp.arguments = [\r\n                            compilerDom.createSequenceExpression([\r\n                                compilerDom.createAssignmentExpression(tempExp, mergedProps),\r\n                                compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), [\r\n                                    tempExp,\r\n                                    compilerDom.createCallExpression(context.helper(SSR_GET_DYNAMIC_MODEL_PROPS), [\r\n                                        tempExp,\r\n                                        vModel.exp // model\r\n                                    ])\r\n                                ])\r\n                            ])\r\n                        ];\r\n                    }\r\n                }\r\n                if (needTagForRuntime) {\r\n                    propsExp.arguments.push(`\"${node.tag}\"`);\r\n                }\r\n                openTag.push(propsExp);\r\n            }\r\n        }\r\n        // book keeping static/dynamic class merging.\r\n        let dynamicClassBinding = undefined;\r\n        let staticClassBinding = undefined;\r\n        // all style bindings are converted to dynamic by transformStyle.\r\n        // but we need to make sure to merge them.\r\n        let dynamicStyleBinding = undefined;\r\n        for (let i = 0; i < node.props.length; i++) {\r\n            const prop = node.props[i];\r\n            // ignore true-value/false-value on input\r\n            if (node.tag === 'input' && isTrueFalseValue(prop)) {\r\n                continue;\r\n            }\r\n            // special cases with children override\r\n            if (prop.type === 7 /* DIRECTIVE */) {\r\n                if (prop.name === 'html' && prop.exp) {\r\n                    rawChildrenMap.set(node, prop.exp);\r\n                }\r\n                else if (prop.name === 'text' && prop.exp) {\r\n                    node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\r\n                }\r\n                else if (prop.name === 'slot') {\r\n                    context.onError(compilerDom.createCompilerError(40 /* X_V_SLOT_MISPLACED */, prop.loc));\r\n                }\r\n                else if (isTextareaWithValue(node, prop) && prop.exp) {\r\n                    if (!needMergeProps) {\r\n                        node.children = [compilerDom.createInterpolation(prop.exp, prop.loc)];\r\n                    }\r\n                }\r\n                else if (!needMergeProps) {\r\n                    // Directive transforms.\r\n                    const directiveTransform = context.directiveTransforms[prop.name];\r\n                    if (directiveTransform) {\r\n                        const { props, ssrTagParts } = directiveTransform(prop, node, context);\r\n                        if (ssrTagParts) {\r\n                            openTag.push(...ssrTagParts);\r\n                        }\r\n                        for (let j = 0; j < props.length; j++) {\r\n                            const { key, value } = props[j];\r\n                            if (compilerDom.isStaticExp(key)) {\r\n                                let attrName = key.content;\r\n                                // static key attr\r\n                                if (attrName === 'key' || attrName === 'ref') {\r\n                                    continue;\r\n                                }\r\n                                if (attrName === 'class') {\r\n                                    openTag.push(` class=\"`, (dynamicClassBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_CLASS), [value])), `\"`);\r\n                                }\r\n                                else if (attrName === 'style') {\r\n                                    if (dynamicStyleBinding) {\r\n                                        // already has style binding, merge into it.\r\n                                        mergeCall(dynamicStyleBinding, value);\r\n                                    }\r\n                                    else {\r\n                                        openTag.push(` style=\"`, (dynamicStyleBinding = compilerDom.createCallExpression(context.helper(SSR_RENDER_STYLE), [value])), `\"`);\r\n                                    }\r\n                                }\r\n                                else {\r\n                                    attrName =\r\n                                        node.tag.indexOf('-') > 0\r\n                                            ? attrName // preserve raw name on custom elements\r\n                                            : shared.propsToAttrMap[attrName] || attrName.toLowerCase();\r\n                                    if (shared.isBooleanAttr(attrName)) {\r\n                                        openTag.push(compilerDom.createConditionalExpression(compilerDom.createCallExpression(context.helper(SSR_INCLUDE_BOOLEAN_ATTR), [value]), compilerDom.createSimpleExpression(' ' + attrName, true), compilerDom.createSimpleExpression('', true), false /* no newline */));\r\n                                    }\r\n                                    else if (shared.isSSRSafeAttrName(attrName)) {\r\n                                        openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_ATTR), [\r\n                                            key,\r\n                                            value\r\n                                        ]));\r\n                                    }\r\n                                    else {\r\n                                        context.onError(createSSRCompilerError(61 /* X_SSR_UNSAFE_ATTR_NAME */, key.loc));\r\n                                    }\r\n                                }\r\n                            }\r\n                            else {\r\n                                // dynamic key attr\r\n                                // this branch is only encountered for custom directive\r\n                                // transforms that returns properties with dynamic keys\r\n                                const args = [key, value];\r\n                                if (needTagForRuntime) {\r\n                                    args.push(`\"${node.tag}\"`);\r\n                                }\r\n                                openTag.push(compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_ATTR), args));\r\n                            }\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                // special case: value on <textarea>\r\n                if (node.tag === 'textarea' && prop.name === 'value' && prop.value) {\r\n                    rawChildrenMap.set(node, shared.escapeHtml(prop.value.content));\r\n                }\r\n                else if (!needMergeProps) {\r\n                    if (prop.name === 'key' || prop.name === 'ref') {\r\n                        continue;\r\n                    }\r\n                    // static prop\r\n                    if (prop.name === 'class' && prop.value) {\r\n                        staticClassBinding = JSON.stringify(prop.value.content);\r\n                    }\r\n                    openTag.push(` ${prop.name}` +\r\n                        (prop.value ? `=\"${shared.escapeHtml(prop.value.content)}\"` : ``));\r\n                }\r\n            }\r\n        }\r\n        // handle co-existence of dynamic + static class bindings\r\n        if (dynamicClassBinding && staticClassBinding) {\r\n            mergeCall(dynamicClassBinding, staticClassBinding);\r\n            removeStaticBinding(openTag, 'class');\r\n        }\r\n        if (context.scopeId) {\r\n            openTag.push(` ${context.scopeId}`);\r\n        }\r\n        node.ssrCodegenNode = compilerDom.createTemplateLiteral(openTag);\r\n    };\r\n};\r\nfunction buildSSRProps(props, directives, context) {\r\n    let mergePropsArgs = [];\r\n    if (props) {\r\n        if (props.type === 14 /* JS_CALL_EXPRESSION */) {\r\n            // already a mergeProps call\r\n            mergePropsArgs = props.arguments;\r\n        }\r\n        else {\r\n            mergePropsArgs.push(props);\r\n        }\r\n    }\r\n    if (directives.length) {\r\n        for (const dir of directives) {\r\n            mergePropsArgs.push(compilerDom.createCallExpression(context.helper(SSR_GET_DIRECTIVE_PROPS), [\r\n                `_ctx`,\r\n                ...compilerDom.buildDirectiveArgs(dir, context).elements\r\n            ]));\r\n        }\r\n    }\r\n    return mergePropsArgs.length > 1\r\n        ? compilerDom.createCallExpression(context.helper(compilerDom.MERGE_PROPS), mergePropsArgs)\r\n        : mergePropsArgs[0];\r\n}\r\nfunction isTrueFalseValue(prop) {\r\n    if (prop.type === 7 /* DIRECTIVE */) {\r\n        return (prop.name === 'bind' &&\r\n            prop.arg &&\r\n            compilerDom.isStaticExp(prop.arg) &&\r\n            (prop.arg.content === 'true-value' || prop.arg.content === 'false-value'));\r\n    }\r\n    else {\r\n        return prop.name === 'true-value' || prop.name === 'false-value';\r\n    }\r\n}\r\nfunction isTextareaWithValue(node, prop) {\r\n    return !!(node.tag === 'textarea' &&\r\n        prop.name === 'bind' &&\r\n        compilerDom.isStaticArgOf(prop.arg, 'value'));\r\n}\r\nfunction mergeCall(call, arg) {\r\n    const existing = call.arguments[0];\r\n    if (existing.type === 17 /* JS_ARRAY_EXPRESSION */) {\r\n        existing.elements.push(arg);\r\n    }\r\n    else {\r\n        call.arguments[0] = compilerDom.createArrayExpression([existing, arg]);\r\n    }\r\n}\r\nfunction removeStaticBinding(tag, binding) {\r\n    const regExp = new RegExp(`^ ${binding}=\".+\"$`);\r\n    const i = tag.findIndex(e => typeof e === 'string' && regExp.test(e));\r\n    if (i > -1) {\r\n        tag.splice(i, 1);\r\n    }\r\n}\r\nfunction findVModel(node) {\r\n    return node.props.find(p => p.type === 7 /* DIRECTIVE */ && p.name === 'model' && p.exp);\r\n}\r\nfunction ssrProcessElement(node, context) {\r\n    const isVoidTag = context.options.isVoidTag || shared.NO;\r\n    const elementsToAdd = node.ssrCodegenNode.elements;\r\n    for (let j = 0; j < elementsToAdd.length; j++) {\r\n        context.pushStringPart(elementsToAdd[j]);\r\n    }\r\n    // Handle slot scopeId\r\n    if (context.withSlotScopeId) {\r\n        context.pushStringPart(compilerDom.createSimpleExpression(`_scopeId`, false));\r\n    }\r\n    // close open tag\r\n    context.pushStringPart(`>`);\r\n    const rawChildren = rawChildrenMap.get(node);\r\n    if (rawChildren) {\r\n        context.pushStringPart(rawChildren);\r\n    }\r\n    else if (node.children.length) {\r\n        processChildren(node.children, context);\r\n    }\r\n    if (!isVoidTag(node.tag)) {\r\n        // push closing tag\r\n        context.pushStringPart(`</${node.tag}>`);\r\n    }\r\n}\n\n// We need to construct the slot functions in the 1st pass to ensure proper\r\n// scope tracking, but the children of each slot cannot be processed until\r\n// the 2nd pass, so we store the WIP slot functions in a weakMap during the 1st\r\n// pass and complete them in the 2nd pass.\r\nconst wipMap$1 = new WeakMap();\r\nconst componentTypeMap = new WeakMap();\r\n// ssr component transform is done in two phases:\r\n// In phase 1. we use `buildSlot` to analyze the children of the component into\r\n// WIP slot functions (it must be done in phase 1 because `buildSlot` relies on\r\n// the core transform context).\r\n// In phase 2. we convert the WIP slots from phase 1 into ssr-specific codegen\r\n// nodes.\r\nconst ssrTransformComponent = (node, context) => {\r\n    if (node.type !== 1 /* ELEMENT */ ||\r\n        node.tagType !== 1 /* COMPONENT */) {\r\n        return;\r\n    }\r\n    const component = compilerDom.resolveComponentType(node, context, true /* ssr */);\r\n    componentTypeMap.set(node, component);\r\n    if (shared.isSymbol(component)) {\r\n        if (component === compilerDom.SUSPENSE) {\r\n            return ssrTransformSuspense(node, context);\r\n        }\r\n        return; // built-in component: fallthrough\r\n    }\r\n    // Build the fallback vnode-based branch for the component's slots.\r\n    // We need to clone the node into a fresh copy and use the buildSlots' logic\r\n    // to get access to the children of each slot. We then compile them with\r\n    // a child transform pipeline using vnode-based transforms (instead of ssr-\r\n    // based ones), and save the result branch (a ReturnStatement) in an array.\r\n    // The branch is retrieved when processing slots again in ssr mode.\r\n    const vnodeBranches = [];\r\n    const clonedNode = clone(node);\r\n    return function ssrPostTransformComponent() {\r\n        // Using the cloned node, build the normal VNode-based branches (for\r\n        // fallback in case the child is render-fn based). Store them in an array\r\n        // for later use.\r\n        if (clonedNode.children.length) {\r\n            compilerDom.buildSlots(clonedNode, context, (props, children) => {\r\n                vnodeBranches.push(createVNodeSlotBranch(props, children, context));\r\n                return compilerDom.createFunctionExpression(undefined);\r\n            });\r\n        }\r\n        let propsExp = `null`;\r\n        if (node.props.length) {\r\n            // note we are not passing ssr: true here because for components, v-on\r\n            // handlers should still be passed\r\n            const { props, directives } = compilerDom.buildProps(node, context);\r\n            if (props || directives.length) {\r\n                propsExp = buildSSRProps(props, directives, context);\r\n            }\r\n        }\r\n        const wipEntries = [];\r\n        wipMap$1.set(node, wipEntries);\r\n        const buildSSRSlotFn = (props, children, loc) => {\r\n            const fn = compilerDom.createFunctionExpression([props || `_`, `_push`, `_parent`, `_scopeId`], undefined, // no return, assign body later\r\n            true, // newline\r\n            true, // isSlot\r\n            loc);\r\n            wipEntries.push({\r\n                fn,\r\n                children,\r\n                // also collect the corresponding vnode branch built earlier\r\n                vnodeBranch: vnodeBranches[wipEntries.length]\r\n            });\r\n            return fn;\r\n        };\r\n        const slots = node.children.length\r\n            ? compilerDom.buildSlots(node, context, buildSSRSlotFn).slots\r\n            : `null`;\r\n        if (typeof component !== 'string') {\r\n            // dynamic component that resolved to a `resolveDynamicComponent` call\r\n            // expression - since the resolved result may be a plain element (string)\r\n            // or a VNode, handle it with `renderVNode`.\r\n            node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_VNODE), [\r\n                `_push`,\r\n                compilerDom.createCallExpression(context.helper(compilerDom.CREATE_VNODE), [\r\n                    component,\r\n                    propsExp,\r\n                    slots\r\n                ]),\r\n                `_parent`\r\n            ]);\r\n        }\r\n        else {\r\n            node.ssrCodegenNode = compilerDom.createCallExpression(context.helper(SSR_RENDER_COMPONENT), [component, propsExp, slots, `_parent`]);\r\n        }\r\n    };\r\n};\r\nfunction ssrProcessComponent(node, context) {\r\n    const component = componentTypeMap.get(node);\r\n    if (!node.ssrCodegenNode) {\r\n        // this is a built-in component that fell-through.\r\n        if (component === compilerDom.TELEPORT) {\r\n            return ssrProcessTeleport(node, context);\r\n        }\r\n        else if (component === compilerDom.SUSPENSE) {\r\n            return ssrProcessSuspense(node, context);\r\n        }\r\n        else if (component === compilerDom.TRANSITION_GROUP) {\r\n            return ssrProcessTransitionGroup(node, context);\r\n        }\r\n        else {\r\n            // real fall-through: Transition / KeepAlive\r\n            // just render its children.\r\n            processChildren(node.children, context);\r\n        }\r\n    }\r\n    else {\r\n        // finish up slot function expressions from the 1st pass.\r\n        const wipEntries = wipMap$1.get(node) || [];\r\n        for (let i = 0; i < wipEntries.length; i++) {\r\n            const { fn, children, vnodeBranch } = wipEntries[i];\r\n            // For each slot, we generate two branches: one SSR-optimized branch and\r\n            // one normal vnode-based branch. The branches are taken based on the\r\n            // presence of the 2nd `_push` argument (which is only present if the slot\r\n            // is called by `_ssrRenderSlot`.\r\n            fn.body = compilerDom.createIfStatement(compilerDom.createSimpleExpression(`_push`, false), processChildrenAsStatement(children, context, false, true /* withSlotScopeId */), vnodeBranch);\r\n        }\r\n        // component is inside a slot, inherit slot scope Id\r\n        if (context.withSlotScopeId) {\r\n            node.ssrCodegenNode.arguments.push(`_scopeId`);\r\n        }\r\n        if (typeof component === 'string') {\r\n            // static component\r\n            context.pushStatement(compilerDom.createCallExpression(`_push`, [node.ssrCodegenNode]));\r\n        }\r\n        else {\r\n            // dynamic component (`resolveDynamicComponent` call)\r\n            // the codegen node is a `renderVNode` call\r\n            context.pushStatement(node.ssrCodegenNode);\r\n        }\r\n    }\r\n}\r\nconst rawOptionsMap = new WeakMap();\r\nconst [baseNodeTransforms, baseDirectiveTransforms] = compilerDom.getBaseTransformPreset(true);\r\nconst vnodeNodeTransforms = [...baseNodeTransforms, ...compilerDom.DOMNodeTransforms];\r\nconst vnodeDirectiveTransforms = Object.assign(Object.assign({}, baseDirectiveTransforms), compilerDom.DOMDirectiveTransforms);\r\nfunction createVNodeSlotBranch(props, children, parentContext) {\r\n    // apply a sub-transform using vnode-based transforms.\r\n    const rawOptions = rawOptionsMap.get(parentContext.root);\r\n    const subOptions = Object.assign(Object.assign({}, rawOptions), { \r\n        // overwrite with vnode-based transforms\r\n        nodeTransforms: [\r\n            ...vnodeNodeTransforms,\r\n            ...(rawOptions.nodeTransforms || [])\r\n        ], directiveTransforms: Object.assign(Object.assign({}, vnodeDirectiveTransforms), (rawOptions.directiveTransforms || {})) });\r\n    // wrap the children with a wrapper template for proper children treatment.\r\n    const wrapperNode = {\r\n        type: 1 /* ELEMENT */,\r\n        ns: 0 /* HTML */,\r\n        tag: 'template',\r\n        tagType: 3 /* TEMPLATE */,\r\n        isSelfClosing: false,\r\n        // important: provide v-slot=\"props\" on the wrapper for proper\r\n        // scope analysis\r\n        props: [\r\n            {\r\n                type: 7 /* DIRECTIVE */,\r\n                name: 'slot',\r\n                exp: props,\r\n                arg: undefined,\r\n                modifiers: [],\r\n                loc: compilerDom.locStub\r\n            }\r\n        ],\r\n        children,\r\n        loc: compilerDom.locStub,\r\n        codegenNode: undefined\r\n    };\r\n    subTransform(wrapperNode, subOptions, parentContext);\r\n    return compilerDom.createReturnStatement(children);\r\n}\r\nfunction subTransform(node, options, parentContext) {\r\n    const childRoot = compilerDom.createRoot([node]);\r\n    const childContext = compilerDom.createTransformContext(childRoot, options);\r\n    // this sub transform is for vnode fallback branch so it should be handled\r\n    // like normal render functions\r\n    childContext.ssr = false;\r\n    // inherit parent scope analysis state\r\n    childContext.scopes = Object.assign({}, parentContext.scopes);\r\n    childContext.identifiers = Object.assign({}, parentContext.identifiers);\r\n    childContext.imports = parentContext.imports;\r\n    // traverse\r\n    compilerDom.traverseNode(childRoot, childContext);\r\n    ['helpers', 'components', 'directives'].forEach(key => {\r\n        childContext[key].forEach((value, helperKey) => {\r\n            if (key === 'helpers') {\r\n                const parentCount = parentContext.helpers.get(helperKey);\r\n                if (parentCount === undefined) {\r\n                    parentContext.helpers.set(helperKey, value);\r\n                }\r\n                else {\r\n                    parentContext.helpers.set(helperKey, value + parentCount);\r\n                }\r\n            }\r\n            else {\r\n                parentContext[key].add(value);\r\n            }\r\n        });\r\n    });\r\n    // imports/hoists are not merged because:\r\n    // - imports are only used for asset urls and should be consistent between\r\n    //   node/client branches\r\n    // - hoists are not enabled for the client branch here\r\n}\r\nfunction clone(v) {\r\n    if (shared.isArray(v)) {\r\n        return v.map(clone);\r\n    }\r\n    else if (shared.isObject(v)) {\r\n        const res = {};\r\n        for (const key in v) {\r\n            res[key] = clone(v[key]);\r\n        }\r\n        return res;\r\n    }\r\n    else {\r\n        return v;\r\n    }\r\n}\n\n// Because SSR codegen output is completely different from client-side output\r\n// (e.g. multiple elements can be concatenated into a single template literal\r\n// instead of each getting a corresponding call), we need to apply an extra\r\n// transform pass to convert the template AST into a fresh JS AST before\r\n// passing it to codegen.\r\nfunction ssrCodegenTransform(ast, options) {\r\n    const context = createSSRTransformContext(ast, options);\r\n    // inject SFC <style> CSS variables\r\n    // we do this instead of inlining the expression to ensure the vars are\r\n    // only resolved once per render\r\n    if (options.ssrCssVars) {\r\n        const varsExp = compilerDom.processExpression(compilerDom.createSimpleExpression(options.ssrCssVars, false), compilerDom.createTransformContext(compilerDom.createRoot([]), options));\r\n        context.body.push(compilerDom.createCompoundExpression([`const _cssVars = { style: `, varsExp, `}`]));\r\n    }\r\n    const isFragment = ast.children.length > 1 && ast.children.some(c => !compilerDom.isText(c));\r\n    processChildren(ast.children, context, isFragment);\r\n    ast.codegenNode = compilerDom.createBlockStatement(context.body);\r\n    // Finalize helpers.\r\n    // We need to separate helpers imported from 'vue' vs. '@vue/server-renderer'\r\n    ast.ssrHelpers = Array.from(new Set([...ast.helpers.filter(h => h in ssrHelpers), ...context.helpers]));\r\n    ast.helpers = ast.helpers.filter(h => !(h in ssrHelpers));\r\n}\r\nfunction createSSRTransformContext(root, options, helpers = new Set(), withSlotScopeId = false) {\r\n    const body = [];\r\n    let currentString = null;\r\n    return {\r\n        root,\r\n        options,\r\n        body,\r\n        helpers,\r\n        withSlotScopeId,\r\n        onError: options.onError ||\r\n            (e => {\r\n                throw e;\r\n            }),\r\n        helper(name) {\r\n            helpers.add(name);\r\n            return name;\r\n        },\r\n        pushStringPart(part) {\r\n            if (!currentString) {\r\n                const currentCall = compilerDom.createCallExpression(`_push`);\r\n                body.push(currentCall);\r\n                currentString = compilerDom.createTemplateLiteral([]);\r\n                currentCall.arguments.push(currentString);\r\n            }\r\n            const bufferedElements = currentString.elements;\r\n            const lastItem = bufferedElements[bufferedElements.length - 1];\r\n            if (shared.isString(part) && shared.isString(lastItem)) {\r\n                bufferedElements[bufferedElements.length - 1] += part;\r\n            }\r\n            else {\r\n                bufferedElements.push(part);\r\n            }\r\n        },\r\n        pushStatement(statement) {\r\n            // close current string\r\n            currentString = null;\r\n            body.push(statement);\r\n        }\r\n    };\r\n}\r\nfunction createChildContext(parent, withSlotScopeId = parent.withSlotScopeId) {\r\n    // ensure child inherits parent helpers\r\n    return createSSRTransformContext(parent.root, parent.options, parent.helpers, withSlotScopeId);\r\n}\r\nfunction processChildren(children, context, asFragment = false, disableNestedFragments = false) {\r\n    if (asFragment) {\r\n        context.pushStringPart(`<!--[-->`);\r\n    }\r\n    for (let i = 0; i < children.length; i++) {\r\n        const child = children[i];\r\n        switch (child.type) {\r\n            case 1 /* ELEMENT */:\r\n                switch (child.tagType) {\r\n                    case 0 /* ELEMENT */:\r\n                        ssrProcessElement(child, context);\r\n                        break;\r\n                    case 1 /* COMPONENT */:\r\n                        ssrProcessComponent(child, context);\r\n                        break;\r\n                    case 2 /* SLOT */:\r\n                        ssrProcessSlotOutlet(child, context);\r\n                        break;\r\n                    case 3 /* TEMPLATE */:\r\n                        // TODO\r\n                        break;\r\n                    default:\r\n                        context.onError(createSSRCompilerError(63 /* X_SSR_INVALID_AST_NODE */, child.loc));\r\n                        // make sure we exhaust all possible types\r\n                        const exhaustiveCheck = child;\r\n                        return exhaustiveCheck;\r\n                }\r\n                break;\r\n            case 2 /* TEXT */:\r\n                context.pushStringPart(shared.escapeHtml(child.content));\r\n                break;\r\n            case 3 /* COMMENT */:\r\n                // no need to escape comment here because the AST can only\r\n                // contain valid comments.\r\n                context.pushStringPart(`<!--${child.content}-->`);\r\n                break;\r\n            case 5 /* INTERPOLATION */:\r\n                context.pushStringPart(compilerDom.createCallExpression(context.helper(SSR_INTERPOLATE), [child.content]));\r\n                break;\r\n            case 9 /* IF */:\r\n                ssrProcessIf(child, context, disableNestedFragments);\r\n                break;\r\n            case 11 /* FOR */:\r\n                ssrProcessFor(child, context, disableNestedFragments);\r\n                break;\r\n            case 10 /* IF_BRANCH */:\r\n                // no-op - handled by ssrProcessIf\r\n                break;\r\n            case 12 /* TEXT_CALL */:\r\n            case 8 /* COMPOUND_EXPRESSION */:\r\n                // no-op - these two types can never appear as template child node since\r\n                // `transformText` is not used during SSR compile.\r\n                break;\r\n            default:\r\n                context.onError(createSSRCompilerError(63 /* X_SSR_INVALID_AST_NODE */, child.loc));\r\n                // make sure we exhaust all possible types\r\n                const exhaustiveCheck = child;\r\n                return exhaustiveCheck;\r\n        }\r\n    }\r\n    if (asFragment) {\r\n        context.pushStringPart(`<!--]-->`);\r\n    }\r\n}\r\nfunction processChildrenAsStatement(children, parentContext, asFragment = false, withSlotScopeId = parentContext.withSlotScopeId) {\r\n    const childContext = createChildContext(parentContext, withSlotScopeId);\r\n    processChildren(children, childContext, asFragment);\r\n    return compilerDom.createBlockStatement(childContext.body);\r\n}\n\nconst ssrTransformModel = (dir, node, context) => {\r\n    const model = dir.exp;\r\n    function checkDuplicatedValue() {\r\n        const value = compilerDom.findProp(node, 'value');\r\n        if (value) {\r\n            context.onError(compilerDom.createDOMCompilerError(57 /* X_V_MODEL_UNNECESSARY_VALUE */, value.loc));\r\n        }\r\n    }\r\n    if (node.tagType === 0 /* ELEMENT */) {\r\n        const res = { props: [] };\r\n        const defaultProps = [\r\n            // default value binding for text type inputs\r\n            compilerDom.createObjectProperty(`value`, model)\r\n        ];\r\n        if (node.tag === 'input') {\r\n            const type = compilerDom.findProp(node, 'type');\r\n            if (type) {\r\n                const value = findValueBinding(node);\r\n                if (type.type === 7 /* DIRECTIVE */) {\r\n                    // dynamic type\r\n                    res.ssrTagParts = [\r\n                        compilerDom.createCallExpression(context.helper(SSR_RENDER_DYNAMIC_MODEL), [\r\n                            type.exp,\r\n                            model,\r\n                            value\r\n                        ])\r\n                    ];\r\n                }\r\n                else if (type.value) {\r\n                    // static type\r\n                    switch (type.value.content) {\r\n                        case 'radio':\r\n                            res.props = [\r\n                                compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                                    model,\r\n                                    value\r\n                                ]))\r\n                            ];\r\n                            break;\r\n                        case 'checkbox':\r\n                            const trueValueBinding = compilerDom.findProp(node, 'true-value');\r\n                            if (trueValueBinding) {\r\n                                const trueValue = trueValueBinding.type === 6 /* ATTRIBUTE */\r\n                                    ? JSON.stringify(trueValueBinding.value.content)\r\n                                    : trueValueBinding.exp;\r\n                                res.props = [\r\n                                    compilerDom.createObjectProperty(`checked`, compilerDom.createCallExpression(context.helper(SSR_LOOSE_EQUAL), [\r\n                                        model,\r\n                                        trueValue\r\n                                    ]))\r\n                                ];\r\n                            }\r\n                            else {\r\n                                res.props = [\r\n                                    compilerDom.createObjectProperty(`checked`, compilerDom.createConditionalExpression(compilerDom.createCallExpression(`Array.isArray`, [model]), compilerDom.createCallExpression(context.helper(SSR_LOOSE_CONTAIN), [\r\n                                        model,\r\n                                        value\r\n                                    ]), model))\r\n                                ];\r\n                            }\r\n                            break;\r\n                        case 'file':\r\n                            context.onError(compilerDom.createDOMCompilerError(56 /* X_V_MODEL_ON_FILE_INPUT_ELEMENT */, dir.loc));\r\n                            break;\r\n                        default:\r\n                            checkDuplicatedValue();\r\n                            res.props = defaultProps;\r\n                            break;\r\n                    }\r\n                }\r\n            }\r\n            else if (compilerDom.hasDynamicKeyVBind(node)) ;\r\n            else {\r\n                // text type\r\n                checkDuplicatedValue();\r\n                res.props = defaultProps;\r\n            }\r\n        }\r\n        else if (node.tag === 'textarea') {\r\n            checkDuplicatedValue();\r\n            node.children = [compilerDom.createInterpolation(model, model.loc)];\r\n        }\r\n        else if (node.tag === 'select') ;\r\n        else {\r\n            context.onError(compilerDom.createDOMCompilerError(54 /* X_V_MODEL_ON_INVALID_ELEMENT */, dir.loc));\r\n        }\r\n        return res;\r\n    }\r\n    else {\r\n        // component v-model\r\n        return compilerDom.transformModel(dir, node, context);\r\n    }\r\n};\r\nfunction findValueBinding(node) {\r\n    const valueBinding = compilerDom.findProp(node, 'value');\r\n    return valueBinding\r\n        ? valueBinding.type === 7 /* DIRECTIVE */\r\n            ? valueBinding.exp\r\n            : compilerDom.createSimpleExpression(valueBinding.value.content, true)\r\n        : compilerDom.createSimpleExpression(`null`, false);\r\n}\n\nconst ssrTransformShow = (dir, node, context) => {\r\n    if (!dir.exp) {\r\n        context.onError(compilerDom.createDOMCompilerError(58 /* X_V_SHOW_NO_EXPRESSION */));\r\n    }\r\n    return {\r\n        props: [\r\n            compilerDom.createObjectProperty(`style`, compilerDom.createConditionalExpression(dir.exp, compilerDom.createSimpleExpression(`null`, false), compilerDom.createObjectExpression([\r\n                compilerDom.createObjectProperty(`display`, compilerDom.createSimpleExpression(`none`, true))\r\n            ]), false /* no newline */))\r\n        ]\r\n    };\r\n};\n\nconst hasSingleChild = (node) => node.children.filter(n => n.type !== 3 /* COMMENT */).length === 1;\r\nconst ssrInjectFallthroughAttrs = (node, context) => {\r\n    // _attrs is provided as a function argument.\r\n    // mark it as a known identifier so that it doesn't get prefixed by\r\n    // transformExpression.\r\n    if (node.type === 0 /* ROOT */) {\r\n        context.identifiers._attrs = 1;\r\n    }\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        node.tagType === 1 /* COMPONENT */ &&\r\n        (compilerDom.isBuiltInType(node.tag, 'Transition') ||\r\n            compilerDom.isBuiltInType(node.tag, 'KeepAlive'))) {\r\n        if (hasSingleChild(node)) {\r\n            injectFallthroughAttrs(node.children[0]);\r\n        }\r\n        return;\r\n    }\r\n    const parent = context.parent;\r\n    if (!parent || parent.type !== 0 /* ROOT */) {\r\n        return;\r\n    }\r\n    if (node.type === 10 /* IF_BRANCH */ && hasSingleChild(node)) {\r\n        injectFallthroughAttrs(node.children[0]);\r\n    }\r\n    else if (hasSingleChild(parent)) {\r\n        injectFallthroughAttrs(node);\r\n    }\r\n};\r\nfunction injectFallthroughAttrs(node) {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 0 /* ELEMENT */ ||\r\n            node.tagType === 1 /* COMPONENT */) &&\r\n        !compilerDom.findDir(node, 'for')) {\r\n        node.props.push({\r\n            type: 7 /* DIRECTIVE */,\r\n            name: 'bind',\r\n            arg: undefined,\r\n            exp: compilerDom.createSimpleExpression(`_attrs`, false),\r\n            modifiers: [],\r\n            loc: compilerDom.locStub\r\n        });\r\n    }\r\n}\n\nconst ssrInjectCssVars = (node, context) => {\r\n    if (!context.ssrCssVars) {\r\n        return;\r\n    }\r\n    // _cssVars is initialized once per render function\r\n    // the code is injected in ssrCodegenTransform when creating the\r\n    // ssr transform context\r\n    if (node.type === 0 /* ROOT */) {\r\n        context.identifiers._cssVars = 1;\r\n    }\r\n    const parent = context.parent;\r\n    if (!parent || parent.type !== 0 /* ROOT */) {\r\n        return;\r\n    }\r\n    if (node.type === 10 /* IF_BRANCH */) {\r\n        for (const child of node.children) {\r\n            injectCssVars(child);\r\n        }\r\n    }\r\n    else {\r\n        injectCssVars(node);\r\n    }\r\n};\r\nfunction injectCssVars(node) {\r\n    if (node.type === 1 /* ELEMENT */ &&\r\n        (node.tagType === 0 /* ELEMENT */ ||\r\n            node.tagType === 1 /* COMPONENT */) &&\r\n        !compilerDom.findDir(node, 'for')) {\r\n        if (compilerDom.isBuiltInType(node.tag, 'Suspense')) {\r\n            for (const child of node.children) {\r\n                if (child.type === 1 /* ELEMENT */ &&\r\n                    child.tagType === 3 /* TEMPLATE */) {\r\n                    // suspense slot\r\n                    child.children.forEach(injectCssVars);\r\n                }\r\n                else {\r\n                    injectCssVars(child);\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            node.props.push({\r\n                type: 7 /* DIRECTIVE */,\r\n                name: 'bind',\r\n                arg: undefined,\r\n                exp: compilerDom.createSimpleExpression(`_cssVars`, false),\r\n                modifiers: [],\r\n                loc: compilerDom.locStub\r\n            });\r\n        }\r\n    }\r\n}\n\nfunction compile(template, options = {}) {\r\n    options = Object.assign(Object.assign(Object.assign({}, options), compilerDom.parserOptions), { ssr: true, inSSR: true, scopeId: options.mode === 'function' ? null : options.scopeId, \r\n        // always prefix since compiler-ssr doesn't have size concern\r\n        prefixIdentifiers: true, \r\n        // disable optimizations that are unnecessary for ssr\r\n        cacheHandlers: false, hoistStatic: false });\r\n    const ast = compilerDom.baseParse(template, options);\r\n    // Save raw options for AST. This is needed when performing sub-transforms\r\n    // on slot vnode branches.\r\n    rawOptionsMap.set(ast, options);\r\n    compilerDom.transform(ast, Object.assign(Object.assign({}, options), { hoistStatic: false, nodeTransforms: [\r\n            ssrTransformIf,\r\n            ssrTransformFor,\r\n            compilerDom.trackVForSlotScopes,\r\n            compilerDom.transformExpression,\r\n            ssrTransformSlotOutlet,\r\n            ssrInjectFallthroughAttrs,\r\n            ssrInjectCssVars,\r\n            ssrTransformElement,\r\n            ssrTransformComponent,\r\n            compilerDom.trackSlotScopes,\r\n            compilerDom.transformStyle,\r\n            ...(options.nodeTransforms || []) // user transforms\r\n        ], directiveTransforms: Object.assign({ \r\n            // reusing core v-bind\r\n            bind: compilerDom.transformBind, \r\n            // model and show has dedicated SSR handling\r\n            model: ssrTransformModel, show: ssrTransformShow, \r\n            // the following are ignored during SSR\r\n            on: compilerDom.noopDirectiveTransform, cloak: compilerDom.noopDirectiveTransform, once: compilerDom.noopDirectiveTransform, memo: compilerDom.noopDirectiveTransform }, (options.directiveTransforms || {}) // user transforms\r\n        ) }));\r\n    // traverse the template AST and convert into SSR codegen AST\r\n    // by replacing ast.codegenNode.\r\n    ssrCodegenTransform(ast, options);\r\n    return compilerDom.generate(ast, options);\r\n}\n\nexports.compile = compile;\n"]}